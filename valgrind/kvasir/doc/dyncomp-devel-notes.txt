DynComp Dynamic Comparability Analysis development notes
by Philip Guo

----------
2005-04-12
----------

When I run dyncomp on 'date' and Memcheck on 'date', dyncomp gives a
lot more uninitialized value warnings.  Memcheck seems to generate
these similar warnings but suppresses them.

dyncomp:
...
==24247== Conditional jump or move depends on uninitialised value(s)
==24247==    at 0x1B8ED585: _dl_relocate_object (in /lib/ld-2.3.2.so)
==24247==    by 0x1B8E6098: (within /lib/ld-2.3.2.so)
==24247==    by 0x1B8F30FC: (within /lib/ld-2.3.2.so)
==24247==    by 0x1B8E4F3A: (within /lib/ld-2.3.2.so)
==24247==    by 0x1B8E4C26: (within /lib/ld-2.3.2.so)
==24247==
==24247== Conditional jump or move depends on uninitialised value(s)
==24247==    at 0x1B8ED3DA: _dl_relocate_object (in /lib/ld-2.3.2.so)
==24247==    by 0x1B8E60DF: (within /lib/ld-2.3.2.so)
==24247==    by 0x1B8F30FC: (within /lib/ld-2.3.2.so)
==24247==    by 0x1B8E4F3A: (within /lib/ld-2.3.2.so)
==24247==    by 0x1B8E4C26: (within /lib/ld-2.3.2.so)
==24247==
==24247== Conditional jump or move depends on uninitialised value(s)
==24247==    at 0x1B8ED3E8: _dl_relocate_object (in /lib/ld-2.3.2.so)
==24247==    by 0x1B8E60DF: (within /lib/ld-2.3.2.so)
==24247==    by 0x1B8F30FC: (within /lib/ld-2.3.2.so)
==24247==    by 0x1B8E4F3A: (within /lib/ld-2.3.2.so)
==24247==    by 0x1B8E4C26: (within /lib/ld-2.3.2.so)
==24247==
==24247== Conditional jump or move depends on uninitialised value(s)
==24247==    at 0x1B8ED585: _dl_relocate_object (in /lib/ld-2.3.2.so)
==24247==    by 0x1B8E60DF: (within /lib/ld-2.3.2.so)
==24247==    by 0x1B8F30FC: (within /lib/ld-2.3.2.so)
==24247==    by 0x1B8E4F3A: (within /lib/ld-2.3.2.so)
==24247==    by 0x1B8E4C26: (within /lib/ld-2.3.2.so)
Tue Apr 12 16:25:24 EDT 2005
==24247==
==24247== ERROR SUMMARY: 20 errors from 8 contexts (suppressed: 0 from 0)
==24247== malloc/free: in use at exit: 6186 bytes in 42 blocks.
==24247== malloc/free: 47 allocs, 5 frees, 8051 bytes allocated.
==24247== For counts of detected errors, rerun with: -v
==24247== searching for pointers to 42 not-freed blocks.
==24247== checked 415748 bytes.
==24247==
==24247== LEAK SUMMARY:
==24247==    definitely lost: 0 bytes in 0 blocks.
==24247==      possibly lost: 0 bytes in 0 blocks.
==24247==    still reachable: 6186 bytes in 42 blocks.
==24247==         suppressed: 0 bytes in 0 blocks.
==24247== Reachable blocks (those to which a pointer was found) are not shown.
==24247== To see them, rerun with: --show-reachable=yes


Memcheck:

Tue Apr 12 16:25:51 EDT 2005
==24386==
==24386== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 20 from 1)
==24386== malloc/free: in use at exit: 6186 bytes in 42 blocks.
==24386== malloc/free: 47 allocs, 5 frees, 8051 bytes allocated.
==24386== For counts of detected errors, rerun with: -v
==24386== searching for pointers to 42 not-freed blocks.
==24386== checked 415748 bytes.
==24386==
==24386== LEAK SUMMARY:
==24386==    definitely lost: 0 bytes in 0 blocks.
==24386==      possibly lost: 0 bytes in 0 blocks.
==24386==    still reachable: 6186 bytes in 42 blocks.
==24386==         suppressed: 0 bytes in 0 blocks.
==24386== Reachable blocks (those to which a pointer was found) are not shown.
==24386== To see them, rerun with: --show-reachable=yes


Notice that Memcheck suppressed 20 warnings but dyncomp didn't.  This
is weird because I've copied dyncomp over from Memcheck and only
changed its name.  Oh well ... maybe the Memcheck developers
suppressed certain errors which only match up with something that's
dependent on the Memcheck name.  This is probably not a big deal since
we don't care about leak checking anyways.


----------
2005-04-13
----------

/* Allocate a new shadow for the given original tmp.  This means any
   previous shadow is abandoned.  This is needed because it is
   necessary to give a new value to a shadow once it has been tested
   for undefinedness, but unfortunately IR's SSA property disallows
   this.  Instead we must abandon the old shadow, allocate a new one
   and use that instead. */
static void newShadowTmp ( MCEnv* mce, IRTemp orig )

In (mc_translate.c):
Check this out.  One of the first problems I need to solve is how
Memcheck automatically sets a byte to defined after it has been tested
for undefinedness in order to avoid propagating errors.  We need to
disable this functionality.


/* Check the supplied **original** atom for undefinedness, and emit a
   complaint if so.  Once that happens, mark it as defined.  This is
   possible because the atom is either a tmp or literal.  If it's a
   tmp, it will be shadowed by a tmp, and so we can set the shadow to
   be defined.  In fact as mentioned above, we will have to allocate a
   new tmp to carry the new 'defined' shadow value, and update the
   original->tmp mapping accordingly; we cannot simply assign a new
   value to an existing shadow tmp as this breaks SSAness -- resulting
   in the post-instrumentation sanity checker spluttering in disapproval.
*/
static void complainIfUndefined ( MCEnv* mce, IRAtom* atom )

From the Memcheck user's manual (mc_main.html):
If a check should detect undefinedness, an error message is
issued. The resulting value is subsequently regarded as
well-defined. To do otherwise would give long chains of error
messages. In effect, we say that undefined values are non-infectious.


I think that commenting out all the complainIfUndefined() calls in
mc_translate.c should do the trick.



/*------------------------------------------------------------*/
/*--- Generate shadow values from all kinds of IRExprs.    ---*/
/*------------------------------------------------------------*/

static
IRAtom* expr2vbits_Binop ( MCEnv* mce,
                           IROp op,
                           IRAtom* atom1, IRAtom* atom2 )

This huge function seems to generate the shadow values for all sorts
of expressions.  Perhaps this is what I should hack on.

The ENSURE_MAPPABLE(addr,caller) macro in mac_shared.h seems to be the
only thing that calls alloc_secondary_map() to allocate a new
secondary map if the current one for the address addr is distinguished
(uninitialized and/or unallocated).


----------
2005-04-14
----------

The best way is to eliminate the tags from the memcheck structures
and just have our own (because their optimization messes us up)

When do we have instructions which create a new value in memory?

Tags are associated with valid V-bits - tags are needed for a byte
when at least 1 V-bit in your byte is valid.  V-bits get set when you
overwrite stuff.  We want to destroy old tag and move a new one in
when none of the original data can be recovered

Globals:
Every byte needs a new unique tag upon program instantiation
There is probably some special case for this

set_address_range_perms is probably what sets all the global area to A
and V; need to do similar things with tags

Stack:
Local variables - upon function entrance, moves ESP down a whole chunk
at a time

int x = 10;
x = 6;
int y = 15;

In x86, you can either have '10' write to a register then write the
register into memory, or have an instruction that directly writes '10'
into memory.  But the important thing to note is that the creation of
the literal '10' is what creates the tag and moves it into either
register or memory.  We need tags associated with registers as well as
memory.

IR is maybe some kind of expression tree which implicitly assigns
names to stuff -

(Maybe) Memcheck must somehow make a new parallel expression tree for
A/V-bits

mc_translate.c

temps
newShadowTmp()?

shadowing - given the tree for the actual expressions, give me the
corresponding one for the V-bits (A-bits don't have to do with
operations, only on memory allocation)

PUT/GET :: STORE/LOAD


expr2vbits_Binop() - the tree-walk which builds up the parallel trees

We start with x86 -> IR tree and then walk it to build up a v-bit tree

Input tree is probably fairly linear but we want a tree representation

IR has two levels - statements and atoms (expressions)

         case Ist_Tmp:
            assign( bb, findShadowTmp(&mce, st->Ist.Tmp.tmp),
                        expr2vbits( &mce, st->Ist.Tmp.data) );
            break;

This seems to be the meaty call

We need some instructions to write to tags just like how they write
instructions to write A and V bits


/* Generate a shadow store.  addr is always the original address atom.
   You can pass in either originals or V-bits for the data atom, but
   obviously not both.  */

static
void do_shadow_STle ( MCEnv* mce,
                      IRAtom* addr, UInt bias,
                      IRAtom* data, IRAtom* vdata )

We need vars to keep track of tags - we need store and load tag
operations in mc_translate.c

We need helpers for store tag, load tag, and merge-two-tags

When we do 32-bit operations, we should just unify them into one tag

LOAD is an expression whereas STORE is a statement

STORE has to be a statement because it has side effects (you can swap
a LOAD/STORE or two STOREs)

Input from the user is conceptually a place where you get new data

If you do ESP + 1, you need to get a new tag because of &-operators

We seem to need a parallel tmpMap

We need to create parallel helper functions to deal with tags:
VGA_REGPARM(1)
UInt MC_(helperc_LOADV1) ( Addr a )



static
void mc_new_mem_startup( Addr a, SizeT len, Bool rr, Bool ww, Bool xx )

static
void mc_new_mem_heap ( Addr a, SizeT len, Bool is_inited )

static
void mc_new_mem_mmap ( Addr a, SizeT len, Bool rr, Bool ww, Bool xx )


We may be able to mc_new_mem_heap to create tags and stuff
and zero stuff out when stack pointer moves


We have two problems to solve:

The easy one: Statically-initialized things - we can simply plug stuff
into mc_main.c.

The hard one: Dynamic events - we need to actually instrument the IR
and do funky stuff.


Do we need any special handling of malloc() and friends?


What do we do with init_new_mem_stack, init_die_mem_stack and friends?


----------
2005-04-17
----------

I turned on 'verboze' in mc_translate.c:TL_(instrument) and diff'ed
two versions of SuperSimpleTest, one with an extra 'int z = x + y;'
statement and here was the main difference:

------ IMark(0x8048375, 3) ------


PUT(56) = 0x8048375:I32


t33 = Add32(t23,0xFFFFFFFC:I32)

   t75 = Or32(t45,0x0:I32)
   t76 = Sub32(0x0:I32,t75)
   t77 = Or32(t75,t76)
   t78 = t77

t15 = LDle:I32(t33)

   t79 = DIRTY 1:I1 RdFX-gst(16,4) RdFX-gst(56,4) ::: MC_(helperc_LOADV4)[rp=1]{0xB125FDF7}(t33)
   t80 = t79

t14 = Add32(t32,t15)

   t81 = Or32(t74,t80)
   t82 = Sub32(0x0:I32,t81)
   t83 = Or32(t81,t82)
   t84 = t83

PUT(32) = 0x3:I32


PUT(36) = t32

   PUT(348) = t74

PUT(40) = t15

   PUT(352) = t80

PUT(44) = 0x0:I32


------ IMark(0x8048378, 3) ------


PUT(56) = 0x8048378:I32


t35 = Add32(t23,0xFFFFFFF4:I32)

   t85 = Or32(t45,0x0:I32)
   t86 = Sub32(0x0:I32,t85)
   t87 = Or32(t85,t86)
   t88 = t87

STle(t35) = t14

   DIRTY 1:I1 RdFX-gst(16,4) RdFX-gst(56,4) ::: MC_(helperc_STOREV4)[rp=2]{0xB125FE46}(t35,t84)



Look in do_shadow_STle:

See the 'void* helper' local variable?  We need to somehow hijack this
one so that we can call our own nifty helper functions at certain
instructions.  From my observation, what Memcheck does is create new
IR trees which contain primitive operations (i.e. AND, OR) on the
V-bits, but there are no primitive operations for "merge tags"
et. al. so that we need to simply suck it up and call our own helper
functions. (Check out setHelperAnns(), unsafeIRDirty_0_N(),
unsafeIRDirty_1_N())

/vex/pub/libvex_ir.h contains some useful IR definitions

IRCallee seems to describe a helper function to call
mkIRCallee(), dopyIRCallee(), etc...

IRExpr_CCall is for pure (no side effects) helper functions whereas
IRStmt_Dirty is for non-pure ones

If you make a dirty call, you must specify EXACTLY which memory areas
you are going to affect, etc...

We definitely need to use tmps to make copies of tags as they flow
from place-to-place.  Otherwise, when there is an operation which
involves two registers (i.e. ADD R1 R2), we have no clue about the
tags of R1 and R2


Super ghetto solution - make a copy of all of the Memcheck
instrumentation code and DUPLICATE it for tags.  Then modify
TL_(instrument) to create BOTH tag and A/V-bit-manipulation
instructions for all inputted instructions


***
What do we do when we read multiple bytes from memory?  Do we merge
the tags associated with all of these bytes and just return one tag?
That seems like it may lose some precision but it's just much easier
to implement (at least for now).
***

helperc_STORE_TAG_4(0x52BFE3BC, 0) [nextTag=110593]
helperc_STORE_TAG_4(0x52BFE3B8, 0) [nextTag=110593]
helperc_STORE_TAG_4(0x52BFE3B4, 0) [nextTag=110593]
helperc_STORE_TAG_4(0x52BFE3B0, 0) [nextTag=110593]
helperc_STORE_TAG_4(0x52BFE3AC, 0) [nextTag=110593]
helperc_STORE_TAG_4(0x52BFE35C, 0) [nextTag=110593]
helperc_LOAD_TAG_4(0x52BFE35C) = 0 [nextTag=110593]
helperc_LOAD_TAG_4(0x52BFE35C) = 0 [nextTag=110593]
helperc_STORE_TAG_4(0x52BFE388, 0) [nextTag=110593]
helperc_LOAD_TAG_4(0x1B8FAC00) = 101377 [nextTag=110593]
helperc_STORE_TAG_4(0x1B8FA66C, 4294967295) [nextTag=110593]   <---- PROBLEM!!!
helperc_STORE_TAG_4(0x1B8FA674, 4294967295) [nextTag=110593]   <---- PROBLEM!!!
helperc_STORE_TAG_4(0x52BFE380, 0) [nextTag=110593]
helperc_LOAD_TAG_4(0x52BFE380) = 0 [nextTag=110593]
helperc_STORE_TAG_4(0x52BFE384, 0) [nextTag=110593]
helperc_LOAD_TAG_4(0x1B8FA674) = 4294967295 [nextTag=110593]   <---- PROBLEM!!!

Look at big-output.pid2528 to see the results of the loads and store
helper function calls: Ummm, there is this mystery garbage value
(4294967295, which is 0xffffffff) likely caused by a bogus store ...
which means that we are storing garbage, which ain't good.

Also other weird garbage values: 4294967280 (0xfffffff0)

I'm trying to get rid of these!!! (Really bad hack - check store
tag values to make sure that they are below 'nextTag', but this is a
bad way to patch up the problem.)

I probably need to clean up the rest of the DynComp code before going
back to this.  Perhaps the rest of the incompatibilities are causing
these bogus values to be stored.  It's still too early to get to the
bottom of this problem.


----------
2005-04-20
----------

Ok, got rid of the garbage values (by disabling handling of unary ops)
and started getting something to work with MERGE_TAGS, except that the
second tag parameter is ALWAYS 0.  That's no good :(

e.g.

helperc_STORE_TAG_4(0x52BFE354, 101913) [nextTag=1466035]
helperc_MERGE_TAGS_4(101913, 0) [nextTag=1466035]
helperc_STORE_TAG_4(0x52BFE350, 110758) [nextTag=1466035]
helperc_MERGE_TAGS_4(101913, 0) [nextTag=1466035]
helperc_STORE_TAG_4(0x52BFE34C, 0) [nextTag=1466035]


!!! Ok, I may have some insight into the problem ... we are using
definedOfType_DC() as a cop-out to create a 0-valued tag, which seems
to clobber the hell out of a lot of valid tag values.  What I really
want is something like a no-op. !!!


----------
2005-04-21
----------

Difference between Put and STle?

      Ist_NoOp,   /* no-op (usually resulting from IR optimisation) */
      Ist_Put,    /* write guest state, fixed offset */
      Ist_PutI,   /* write guest state, run-time offset */
      Ist_Tmp,    /* assign value to temporary */
      Ist_STle,   /* little-endian write to memory */

Look at Ist_NoOp!
extern IRStmt* IRStmt_NoOp

/* Convenience function for constructing clean helper calls. */
IRExpr* mkIRExprCCall

Stephen's suggestions from our meeting today:

Ideally, we want to somehow replicate the tree structure of the
original IR except for the fact that our binary operations are merges.
Our merge operations should return the canonical tag of the merged
sets in the temporary so that it can be used further up the chain.
mkIRExprCCall can be our savior by providing a way to make a 'clean' C
function call as an IRExpr, which can fit in our parallel IR
expression tree.  E.g.

    (sub)
    /  \
   /    \
 (add)  C
  / \
 /   \
 A   B

becomes ...

   (merge)
    /  \
   /    \
(merge) Ctag
  / \
 /   \
Atag Btag

Each (merge) merges the sets of the tags and returns the canonical tag
of the set so that it can be used in further merges.  This is very
important!

We need to try to use clean calls since they can fit in our expression
tree (hopefully) and not dirty calls because they are statements
(maybe?).



Ok, onto another issue ... optimization of tag mergings.  When we
union uf_objects pointed-to by tags, what we really want is to return
the tag of the canonical uf_object (the root of the tree) so that it
can be stored away.  This will help in garbage collection because it
ensures that we will have the smallest possible set of distinct tags
floating around at any one time.  Conceptually, we have two maps
(implemented as two-level sparse arrays):

tag_map: Addr --> tag
uf_object_map: tag --> uf_object

Whenever we perform a union of uf_objects in uf_object_map, we want to
also return the tag of the canonical (root) uf_object in the set.

Here is an example:

tag_map
-------
Addr:   1   2   3   4   5
tag:    10  20  30  40  50

uf_object_map
-------------
tag:        1 ... 10 ... 20 ... 30 ... 40 ... 50
uf_object:        A      B      C      D      E

Let's say you merge A, B, C, D, and E.  What we really want is to
return 10 (the tag of A) as the result of this merge.  That way, if we
assign the results of the merge into any new variable, it will show up
as 10.  So if we clobber addresses 2, 3, 4, and 5 with the results of
the merge, all of them will end up being 10 and we can garbage collect
tags 20, 30, 40, and 50.

To implement this with the two-level uf_object_map, we need to somehow
provide an efficient reverse mapping of uf_object --> tag.  My
suggestion is to keep a backpointer to the space in
primary_uf_object_map when you malloc each 2^16 secondary array of
uf_objects so that you can do a two-level pointer offset arithmetic to
get the tag, when given an uf_object*.

However, I want to defer the implementation of this optimization
because I don't see right off the bat how it will help us out too
much.  I want to have some more time to think about it first.

... ok, I thought about it.  It would be really helpful in the
helperc_LOAD_TAG... series of functions, where we are loading the tags
for several bytes (2, 4, or 8) and doing a union because we figure
heuristically that if you are reading 4 (or whatever) bytes from
memory, you really mean for those 4 bytes to have the SAME tag.  Right
now, we simply union the tags, but as a side effect, we should really
set the tags for all those relevant bytes to the CANONICAL (root)
tag.  In the above example, let's say that we were reading Addr 1, 2,
3, 4 as one block.  If 10 were the canonical tag for the union of A,
B, C, D, then we want to set the tags as follows:

tag_map
-------
Addr:   1   2   3   4   5
tag:    10  10  10  10  50

... which would allow tags 20, 30, and 40 to be garbage collected.

Ok, I'm now convinced that I should go thru with this optimization.


In order to simplify the implementation, I will just keep the 4-byte
tag along with each uf_object structure.  This wastes a bit of space,
bloating it from 8 to 12 bytes each, but it eliminates lots of
implementation complexities.


^^^^^^^^^^^^^^^^^^^^^^^^^^
Garbage collection idea!!!

When you're doing the mark-sweep garbage collection, clobber every
single tag with the canonical tag found using find_canonical_tag().
If we are pretty sure that there are relatively few distinct sets
(lots of merging occurs), then replacing each tag in shadow memory
(tag_map) with its canonical tag will better enable us to recycle
tags.
^^^^^^^^^^^^^^^^^^^^^^^^^^


Dude, something looks good:

SuperSimpleTest.c:

int main() {
  int x = 5;
  int y = 10;
  int z = x + y;
  printf("&x=%p, &y=%p, &z=%p\n", &x, &y, &z);
  return 0;
}


Program output:
&x=0x52bfe354, &y=0x52bfe350, &z=0x52bfe34c

Possibly an interesting part:

helperc_STORE_TAG_4(0x52BFE358, 0) [nextTag=1768769]
helperc_CREATE_TAG() = 1768769 [nextTag=1768770]
helperc_MERGE_TAGS_4(0, 1768769) [nextTag=1768770]
helperc_CREATE_TAG() = 1768770 [nextTag=1768771]
helperc_MERGE_TAGS_4(0, 1768770) [nextTag=1768771]
helperc_CREATE_TAG() = 1768771 [nextTag=1768772]
helperc_MERGE_TAGS_4(0, 1768771) [nextTag=1768772]
helperc_CREATE_TAG() = 1768772 [nextTag=1768773]
helperc_CREATE_TAG() = 1768773 [nextTag=1768774]
helperc_MERGE_TAGS_4(0, 1768773) [nextTag=1768774]
helperc_CREATE_TAG() = 1768774 [nextTag=1768775]             <-- create tag for '5'
helperc_STORE_TAG_4(0x52BFE354, 1768774) [nextTag=1768775]   <-- Assign '5' to x; tag(x) = 1768774
helperc_CREATE_TAG() = 1768775 [nextTag=1768776]
helperc_CREATE_TAG() = 1768776 [nextTag=1768777]
helperc_MERGE_TAGS_4(0, 1768776) [nextTag=1768777]
helperc_CREATE_TAG() = 1768777 [nextTag=1768778]             <-- create tag for '10'
helperc_STORE_TAG_4(0x52BFE350, 1768777) [nextTag=1768778]   <-- Assign '10' to y; tag(y) = 1768777
helperc_CREATE_TAG() = 1768778 [nextTag=1768779]
helperc_CREATE_TAG() = 1768779 [nextTag=1768780]
helperc_MERGE_TAGS_4(0, 1768779) [nextTag=1768780]
helperc_LOAD_TAG_4(0x52BFE350) = 1768777 [nextTag=1768780]   <-- Load y into register; tag(y) = 1768777
helperc_CREATE_TAG() = 1768780 [nextTag=1768781]
helperc_CREATE_TAG() = 1768781 [nextTag=1768782]
helperc_MERGE_TAGS_4(0, 1768781) [nextTag=1768782]
helperc_LOAD_TAG_4(0x52BFE354) = 1768774 [nextTag=1768782]   <-- Load x into register; tag(x)= 1768774
helperc_MERGE_TAGS_4(1768777, 1768774) [nextTag=1768782]     <-- Do 'x + y'; Merge tag(x) & tag(y)
helperc_CREATE_TAG() = 1768782 [nextTag=1768783]
helperc_CREATE_TAG() = 1768783 [nextTag=1768784]
helperc_CREATE_TAG() = 1768784 [nextTag=1768785]
helperc_CREATE_TAG() = 1768785 [nextTag=1768786]
helperc_MERGE_TAGS_4(0, 1768785) [nextTag=1768786]
helperc_STORE_TAG_4(0x52BFE34C, 1768777) [nextTag=1768786]   <-- Assign 'x + y' to z; tag(z) = tag(x) = 1768777



Uhhh, we still have lots of extraneous CREATE_TAG() calls without
being assigned to variables in memory, but the garbage collector
should take care of that.


----------
2005-04-22
----------

Stephen suggested that we count all binary ops as interactions
(because they all consist of data flow) unless otherwise noted
(e.g. shift operators, or operator, etc...).

z = x << y implies that z and x are comparable to one another, but not
to y.  That means that we simply copy the tag over from x to z and not
merge with the tag of y.

Some things shouldn't count as interactions at all (i.e. z = x || y)
so just pass along a 0 tag.


Ummm, now it barfs on ArrayTest with this error:

==5448==  Address 0x1BB3A000 is not stack'd, malloc'd or (recently) free'd
buffer population[999]: 134516768
buffer multiDimensional[4][5][12]: 0x804a720

vex: the `impossible' happened:
   genGuestArrayOffset(x86 host)
vex storage:  P 436,  T total 64171040 (1905138),  T curr 53956 (1654)

valgrind: the `impossible' happened:
   LibVEX called failure_exit().
==5448==    at 0xB0022A71: ???
==5448==    by 0xB0022A70: ???
==5448==    by 0xB0022A99: ???
==5448==    by 0xB0049C29: ???
==5448==    by 0xB0061561: ???
==5448==    by 0xB006ED5C: ???
==5448==    by 0xB0075A28: ???
==5448==    by 0xB0076114: ???
==5448==    by 0xB0060FE0: ???
==5448==    by 0xB004A1BA: ???
==5448==    by 0xB00136D7: ???
==5448==    by 0xB0013B17: ???

Basic block ctr is approximately 32990

sched status:
  running_tid=1

Thread 1: status = VgTs_Runnable
==5448==    at 0x80484CE: main (ArrayTest.c:96)


Ok, I'm trying to run dyncomp on the programs in the Kvasir test
suite.  This is all done with the CVS check-in at:
Fri Apr 22 16:03:55 EDT 2005

Or, in CVS time: 2005-04-22 20:04:56 +0000

Success:

bc
BinaryTreeTest
DisambigTest
Dstr
function-pointer
GlobalTest
inline-func
ManualDisambigExample
md5
MultiDimArrayTest
MultipleStructsTest
NestedStructTest
partial-init
pointer-levels
PointerTest
rijndael
shared-lib
SimpleDisambigStructTest
small-test
StackArrayCppTest
StackCppTest
StaticArraysTest
static-struct
string-arrays
StructPtrTest
tcas
two-statics
virtual-method

Failure (all with the genGuestArrayOffset(x86 host) problem):

ArrayTest
ArrayTest-cpp
ArraysInStructTest
crazy-test-1
TrivialTest
TypedefTest
TypesTest

Special failures:

IntTest

IN STATEMENT:

t325 = x86g_check_fldcw{0xB00838CA}(t73):I64

ERROR = IRStmt.Put.Tmp: tmp and expr do not match


vex: the `impossible' happened:
   sanityCheckFail: exiting due to bad IR
vex storage:  P 436,  T total 55547180 (1646556),  T curr 137076 (4325)



Now I need to figure out what exactly makes these programs fail and
generate the smallest possible example which reproduces this bug.

In TypesTest, if you remove the stuff which deals with doubles and
floats, it seems like you're fine:

    printf("returnDoubleSum(%f, %f) = %f\n",
	   (float)((a+b)/7),
	   (double)((2/b)*a),
	   returnDoubleSum((float)((a+b)/7), (double)((2/b)*a)));
    printf("returnFloatProduct(%f, %f) = %f\n",
	   (float)((b/9)+a*3.14159),
	   (float)(b*a+6/7*3),
	   returnFloatProduct((float)((b/9)+a*3.14159), (float)(b*a+6/7*3)));


I extracted this out into FloatTest under dyncomp-tests, which is a
tiny program that reproduces the genGuestArrayOffset() bug.

It seems like any conversion to a float triggers this error.


(On another note, all the Memcheck warnings we're getting with the
dyncomp-instrumented code - interestingly, only system calls - are
pesky.  Maybe something to do with helper functions, perhaps the dirty
ones messing up v-bits)


V-bits overriding problem:
The main problem here (we think) is that the shadow guest state is a
fixed size (the same size as the original guest state), which works
well for Memcheck, but not for us.  We need more space!!!


----------
2005-04-23
----------

Yeah, there is only one shadow guest state for Memcheck (too bad it's
hardcoded into Vex) and BOTH dyncomp AND Memcheck are sharing it,
which means that we are clobbering V-bit information in the guest
state (registers and stuff).  That's probably why we are getting so
many bogus Memcheck errors.  To solve this, we need to somehow
allocate more guest state.


Floating point crash:

int main() {
  unsigned int a = 10;
  float c = (float)a;
  return 0;
}

vex: the `impossible' happened:
   genGuestArrayOffset(x86 host)
vex storage:  P 436,  T total 58577752 (1707030),  T curr 107796 (3293)


But this works:

int main() {
  float c = 5;
  return 0;
}

Actually, this may be related to the floating-point crash because
getGuestArrayOffset() depends on the guest floating point array and if
the sizes are bogus, then we're screwed.

The problem is eliminated when you get rid of the handlers for Ist_PutI:

case Ist_PutI:
//            do_shadow_PUTI_DC( &dce,
//                               st->Ist.PutI.descr,
//                               st->Ist.PutI.ix,
//                               st->Ist.PutI.bias,
//                               st->Ist.PutI.data );
break;

It's got something to do with the indexing done in do_shadow_PUTI_DC.

From Iex_GetI ...
From Ist_PutI ...
From Ist_PutI ...

vex: the `impossible' happened:
   genGuestArrayOffset(x86 host)
vex storage:  P 436,  T total 58577752 (1707030),  T curr 107796 (3293)


Yep, the debug. output confirms something fishy in PUTI_DC.

Backtrace:

Breakpoint 2, genGuestArrayOffset (env=0xb0275a64, descr=0xb0269b3c, off=0x4,
    bias=-1) at priv/host-x86/isel.c:586
(gdb) bt
#0  genGuestArrayOffset (env=0xb0275a64, descr=0xb0269b3c, off=0x4, bias=-1)
    at priv/host-x86/isel.c:586
#1  0xb0075a59 in iselStmt (env=0xb0275a64, stmt=0xb0274c00)
    at priv/host-x86/isel.c:3295
#2  0xb0076145 in iselBB_X86 (bb=0xb026da38, subarch_host=123)
    at priv/host-x86/isel.c:3519
#3  0xb0060fe1 in LibVEX_Translate (arch_guest=VexArchX86,
    subarch_guest=VexSubArchX86_sse2, arch_host=2955336248,
    subarch_host=VexSubArchX86_sse2,
    guest_bytes=0x8048354 "U\211е\203м\b\203дрё", guest_bytes_addr=134513492,
    chase_into_ok=0x4, guest_extents=0xb0862ef4,
    host_bytes=0xb0259aa0 "\213\235L\001", host_bytes_size=20000,
    host_bytes_used=0x4, instrument1=0xb0046f44 <vgToolInternal_instrument>,
    instrument2=0xb004958e <vg_SP_update_pass>,
    cleanup_after_instrumentation=1 '\001', byte_accessible=0x4, traceflags=4)
    at priv/main/vex_main.c:492
#4  0xb004a1bb in vgPlain_translate (tid=1, orig_addr=134513492,
    debugging_translation=0 '\0', debugging_verbosity=0)
    at libvex_basictypes.h:151
#5  0xb00136d8 in handle_tt_miss (tid=1) at vg_scheduler.c:653
#6  0xb0013b18 in vgPlain_scheduler (tid=1) at vg_scheduler.c:768
#7  0xb005835d in vgArch_thread_wrapper (tidW=1) at core_os.c:41
#8  0x00000000 in ?? ()


This is the statement that it supposedly comes from:

(gdb) p *stmt
$7 = {tag = Ist_PutI, Ist = {NoOp = {<No data fields>}, IMark = {
      addr = 12692904998714383164, len = -1}, Put = {offset = -1339647172,
      data = 0xb02641d8}, PutI = {descr = 0xb0269b3c, ix = 0xb02641d8,
      bias = -1, data = 0xb0269ad8}, Tmp = {tmp = 2955320124,
      data = 0xb02641d8}, STle = {addr = 0xb0269b3c, data = 0xb02641d8},
    Dirty = {details = 0xb0269b3c}, MFence = {<No data fields>}, Exit = {
      guard = 0xb0269b3c, jk = 2955297240, dst = 0xffffffff}}}

pgbovine@parsnip:~/research/invariants/valgrind-3/vex$ grep -r x86guest_layout *
...
priv/guest-x86/gdefs.h:VexGuestLayout x86guest_layout;
priv/guest-x86/ghelpers.c:   x86guest_layout
priv/main/vex_main.c:         guest_layout     = &x86guest_layout;
...


pub/libvex_guest_x86.h:   VexGuestX86State;

pub/libvex.h: Check this out - it hardcodes the 2X size:
/* A note about guest state layout.

   LibVEX defines the layout for the guest state, in the file
   pub/libvex_guest_<arch>.h.  The struct will have an 8-aligned size.
   Each translated bb is assumed to be entered with a specified
   register pointing at such a struct.  Beyond that is a shadow
   state area with the same size as the struct.  Beyond that is
   a spill area that LibVEX may spill into.  It must have size
   LibVEX_N_SPILL_BYTES, and this must be a 16-aligned number.

   On entry, the baseblock pointer register must be 8-aligned.
*/

coregrind/x86/core_arch.h:      UChar vex_spill[LibVEX_N_SPILL_BYTES];

Here is where the shadow is FIXED!!!

typedef
   struct {
      /* --- BEGIN vex-mandated guest state --- */

      /* Saved machine context. */
      VexGuestX86State vex;

      /* Saved shadow context. */
      VexGuestX86State vex_shadow;

      /* Spill area. */
      UChar vex_spill[LibVEX_N_SPILL_BYTES];

      /* --- END vex-mandated guest state --- */
   }
   ThreadArchState;

Look at where the 2 is hardcoded! YUCK!

valgrind: vg_scheduler.c:484 (run_thread_for_a_while): Assertion `a_vex + 2 * sz_vex == a_spill' failed.


I'm changing it to add a vex_shadow_2 field to ThreadArchState.  Note
that this blows because I'll need to change it for EVERY architecture,
but that's ok since we're only doing x86 for now.

but now it segfaults :( bah


----------
2005-04-25
----------

We want to use 8-byte stores into guest state ONLY for PUTI (using the
IR conversion functions).

vex/priv/host-generic/reg_alloc2.c:684

      /* This reflects LibVEX's hard-wired knowledge of the baseBlock
         layout: the guest state, then an equal sized area following
         it for shadow state, and then the spill area. */
      vreg_lrs[j].spill_offset = toShort(guest_sizeB * 2 + k * 8);

ThreadArchState is within ThreadState (defined in coregrind/core.h)

./priv/host-generic/reg_alloc2.c:      // PG - modified offset from 2 to 6 (look in core_arch.h)
./priv/host-x86/isel.c:      // PG - Add handling for 4-byte PUTI's for tags



Ok, we fixed three problems today:
1.) Floating point stack problem (as evident in FloatTest)

The problem was that PUTI (Indexed PUT) is only used to write to the
floating-point stack, but Vex currently only allows 8-byte and 1-byte
writes for PUTI, 8-byte for doubles and 1-byte for the floating-point
'tags' (not the same as our tags).  We need to make an indexed 4-byte
write, so we simply relaxed a few assertions an added a case in the
x86->IR translator to handle 4-byte PUTI's.

Changes:

./priv/host-x86/isel.c:

Line 588:
   // PG - Added support for 4-byte writes of DynComp tags
   if (nElems != 8 || (elemSz != 1 && elemSz != 4 && elemSz != 8))
      vpanic("genGuestArrayOffset(x86 host)");

Line 608:
   // PG - Added support for 4-byte writes of DynComp tags
   vassert(elemSz == 1 || elemSz == 4 || elemSz == 8);
   // PG - Added support for 4-byte writes of DynComp tags
   return
      X86AMode_IRRS( descr->base, hregX86_EBP(), tmp,
                     elemSz==8 ? 3 :
                                 elemSz==4 ? 2 : 0);
}

Line 3313:
      // PG - Add handling for 4-byte PUTI's for tags
      if (ty == Ity_I32) {
         X86RI* ri = iselIntExpr_RI(env, stmt->Ist.PutI.data);
         addInstr(env, X86Instr_Alu32M(Xalu_MOV,ri,am));
         return;
      }


2.) Tags and V-bits clobbering each other because they both refer to
the same place in the shadow guest state

This change was a bit more involved.  The fundamental problem is that
Vex and Valgrind assume that tools will only need one fixed-sized
shadow guest state (for holding metadata about register,
floating-point stack, etc...).  We believe that this design decision
was made in order to make Memcheck work because Memcheck requires only
one shadow guest state for the V-bits.  However, we want to maintain
our own shadow guest state, which requires 4 bytes for EVERY field
of VexGuestX86State (we're just focusing on x86 for now).

The reason why we were getting all of those weird Memcheck errors when
running with DynComp was because both Memcheck and DynComp were
sharing the SAME shadow guest state (vex_shadow field in
ThreadArchState) and thus DynComp tags were being mis-interpreted as
V-bits.

Here is the hack that we used to resolve this problem:

In valgrind/coregrind/x86/core_arch.h, it's hard-coded into
ThreadArchState that there is one vex_shadow, so we just created an
extra shadow (called vex_extra_shadow) which is 4 times as big as the
original one.

valgrind/coregrind/x86/core_arch.h:

typedef
   struct {
      /* --- BEGIN vex-mandated guest state --- */

      /* Saved machine context. */
      VexGuestX86State vex;

      /* Saved shadow context. */
      VexGuestX86State vex_shadow;

      /* PG - Extra shadow guest state for DynComp */
      VexGuestX86State vex_extra_shadow[4];

      /* Spill area. */
      UChar vex_spill[LibVEX_N_SPILL_BYTES];

      /* --- END vex-mandated guest state --- */
   }
   ThreadArchState;


We need it to be 4X larger because we need a 4-byte tag for EVERY
field of VexGuestX86State, and the smallest entry is a 1-byte Char.
Now we need to multiply all offsets into vex_extra_shadow by 4 and all
should be well.  To properly handle GET, GETI, PUT, and PUTI calls for
DynComp, we must use the base value of TWICE total_sizeB (size of
VexGuestX86State) in order to get to the beginning of vex_extra_shadow
and then multiply all offsets by 4 because vex_extra_shadow is 4X the
size of a VexGuestX86State structure.

Modified functions in mc_translate.c:
do_shadow_PUT_DC, do_shadow_PUTI_DC, do_shadow_GET_DC, do_shadow_GETI_DC

e.g.
   stmt( dce->bb, IRStmt_Put( (4 * offset) + (2 * dce->layout->total_sizeB), vatom ) );

Now we also need to relax an assertion in ...

valgrind/coregrind/vg_scheduler.c:485
   // PG - changed from 2 to 6 to account for vex_extra_shadow in ThreadArchState
   vg_assert(a_vex + 6 * sz_vex == a_spill);

and finally modify the offset of the spill area in Vex:

vex/priv/host-generic/reg_alloc2.c:685

   // PG - changed from 2 to 6 to account for vex_extra_shadow in ThreadArchState
      vreg_lrs[j].spill_offset = toShort(guest_sizeB * 6 + k * 8);


3.) Multiplexor problem in IntTest This was dumb.  I need to simply
multiplex the values of the V-bits and pass them along within
expr2tags_Mux0X_DC.  I didn't do anything to handle this case before
so the IR was invalid.


TypesTest still fails!!! ARGGGGGG.

returnULongProduct(10000000, 0) = 1187331820519724672
GETI(880:8xI32)[t65,0]
vex: the `impossible' happened:
   iselIntExpr_R: cannot reduce tree
vex storage:  P 436,  T total 66334080 (1949455),  T curr 183020 (5359)

Look into this sometime.  It has to do with some double floating point
thing, since if we comment this out, it works:

/*     printf("returnDoubleSum(%f, %f) = %f\n", */
/* 	   (float)((a+b)/7), */
/* 	   (double)((2/b)*a), */
/* 	   returnDoubleSum((float)((a+b)/7), (double)((2/b)*a))); */


----------
2005-04-26
----------

This tiny program replicates the problem above.

double returnDoubleSum(double a, double b)
{
  return 0;
}

int main() {
  returnDoubleSum(1, 2);
  return 0;
}



GETI(880:8xI32)[t7,0]
vex: the `impossible' happened:
   iselIntExpr_R: cannot reduce tree

parsnip:/scratch/pgbovine-do-not-delete-me/xtide/bin/xtide
shares the SAME failure


Hmm, if I comment-out handling for:

      case Iex_Mux0X:
         return IRExpr_Const(IRConst_U32(0));
         //         return expr2tags_Mux0X_DC( dce, e->Iex.Mux0X.cond, e->Iex.Mux0X.expr0,
         //                                    e->Iex.Mux0X.exprX);

... everything seems to work properly

But it may have something to do with CCall.  Look in isel.c for
'irreducible':

For CCalls:
      /* be very restrictive for now.  Only 32/64-bit ints allowed
         for args, and 32 bits for return type. */
      if (e->Iex.CCall.retty != Ity_I32)
         goto irreducible;

but the problem may not be in CCall at all.  If nothing matches in the
switch statement, this line still executes:

   /* We get here if no pattern matched. */
  irreducible:
   ppIRExpr(e);
   vpanic("iselIntExpr_R: cannot reduce tree");


GETI is most likely the culprit!
GETI(880:8xI32)[t7,0]

It's just another instance of the 'not-supporting 4-byte get/put' for
x87 floating-point stack in isel.c:

Add this line to isel.c and all should be well :)

      // PG - Add support for 32-bit GETI's for DynComp tags
      if (ty == Ity_I32) {
         addInstr(env, X86Instr_Alu32R(
                          Xalu_MOV,
                          X86RMI_Mem(am),
                          dst));
         return dst;
      }


Clean calls are intuitively the correct thing for tag MERGES (and
they're faster), although they may be optimized away in some special
cases.

Do a clean call for most merges and do a few dirty calls to 'anchor'
the computation so that the optimizer doesn't optimize stuff away.

For the MUX and conditional exit (i.e., if (expr1) goto
literal-value), add a no-op dirty call which takes 1 tag in and does
nothing so that the optimizer doesn't destroy it.

e.g.

Mux: 'Mux0X(exprC, expr0, exprX)'

Conceptually, the return value of processing the tags for this
expression is just a parallel Mux with the SAME condition but the tags
of the expressions:

Mux0X(exprC, tag(expr0), tag(exprX))

Although exprC is an IRAtom (temp or constant), a super-complicated
expression might have resulted in that temp.  What if exprC is TEMP
which is the result of evaluating a complicated expression with lots
of interesting interactions?  The IR optimizer might blow away the
tree branch containing all of the interesting tag merges if the
resulting temp is not used anywhere (since all the tag merges are
clean calls).  Thus, we need to anchor it by adding a temporary t with
a dirty call (which cannot be optimized away) such that:

t = dirty_NOP(tag(exprC))

We don't really use t for anything, but we need it as an ANCHOR to
prevent the optimizer from blowing away tag merge interactions arising
from exprC.

Conditional exits: 'if (expr1) goto literal-value'

Ditto for expr1 here.


----------
2005-04-27
----------

Questions for Stephen during our weekly meeting (Look at TODO's):

1. Do we have the annotations for the dirty helpers correct for MERGE_TAG
and CREATE_TAG (as stated in setHelperAnns_DC()).  I guess we don't
explicitly access guest state in either of these.

They can probably go away because SP and IP are only accessed during
error reporting (backtraces)

2. Are the AND, OR, etc... binary ops. bitwise by default?  If so, we
should count them as interactions?  But what about logical AND/OR?  We
don't want to count (apples || oranges) as interactions, but if it
gets translated into the same IR instructions as (apples | oranges),
then we can't tell the difference, right?  We need to err one way or
another, and I think that logical AND/OR in C are more common than
bitwise ones.

BITWISE! - Logical AND's and OR's are compiled as branches.

3. Make sure my handling of unary ops (no handling at all) is correct.

Good.

4. How do pointer values get created using &-operator and malloc?  I
guess I'll experiment and find out.

It will either look like a literal or arithmetic on ESP/EBP.  Right
now we don't create new tags on malloc and friends.  It's not clear
that tags for pointers are that important.

5. Optimization - how do we avoid all of these CREATE_TAGS when most
of them are useless?

6. Perhaps most important.  Ok, I got how to do function entrances,
but how do I do function exits without the address available in the
Ist_Exit statement?  Maybe I need to cue off of the PREVIOUS IMark
statement, which seems like a pain.  Yeah, this seems to work, but is
there an easier way?

Check out libvex_ir.h:

Look at the Ret jump kind for function exits?

typedef
   enum {
      Ijk_Boring=0x14000, /* not interesting; just goto next */
      Ijk_Call,           /* guest is doing a call */
      Ijk_Ret,            /* guest is doing a return */
      Ijk_ClientReq,      /* do guest client req before continuing */
      Ijk_Syscall,        /* do guest syscall before continuing */
      Ijk_Yield,          /* client is yielding to thread scheduler */
      Ijk_EmWarn,         /* report emulation warning before continuing */
      Ijk_NoDecode,       /* next instruction cannot be decoded */
      Ijk_MapFail,        /* Vex-provided address translation failed */
      Ijk_TInval          /* Invalidate translations before continuing. */
   }
   IRJumpKind;

Also look into Ist_IMark for markers for function entrance/exit!


----------
2005-04-28
----------

In tool.h, it looks like you can register Valgrind tools to pick up on
specific events, such as ESP changing.  Perhaps this is more elegant
than hacking mac_shared.h directly to put in our own check_ESP(), but
maybe it would be slower.

Perhaps think about making a Fjalar 1.0 which abstracts out the common
parts of Kvasir and DynComp.  During our crazy variable traversal,
take a function pointer parameter so that we can polymorphically do
dtrace or DynComp output.  Create nice abstractions.

How do we get R_ESP???  In CHECK_ESP(), you can get it from the
argument.  But how do you get it into the argument?  We need some IR
statement which grabs the guest state's ESP wheneve it's executed.

When you annotate a dirty helper to say that it uses the ESP, then it
ensures that ESP is written to the guest state.

Ha! In tool.h:

/* Get the TID of the thread which currently has the CPU. */
extern ThreadId VG_(get_running_tid) ( void );

/* Searches through all thread's stacks to see if any match.  Returns
   VG_INVALID_THREADID if none match. */
extern ThreadId VG_(first_matching_thread_stack)
                        ( Bool (*p) ( Addr stack_min, Addr stack_max, void* d ),
                          void* d );

/* Get parts of the client's state. */
extern Addr VG_(get_SP) ( ThreadId tid );
extern Addr VG_(get_IP) ( ThreadId tid );



Hmmm, check out this thing about shadow memory from tool.h:

/* Does the tool need shadow memory allocated (if you set this, you must also statically initialize
   float TL_(shadow_ratio) = n./m;
   to define how many shadow bits you need per client address space bit.
*/
extern void VG_(needs_shadow_memory)( void );
extern float TL_(shadow_ratio);


Hmmm, wait I don't think we need to hack around using the actual x86
floating-point stack anymore.  We actually have a shadow
floating-point stack now :)

Hmmm, the problem now seems to be that I can't properly get
floating-point return values off of the top of the guest_FPREG.
Perhaps my dirty helper annotations in handle_possible_exit_DC()
aren't correct or something, but it ain't working.

An alternative is that we could add an explicit GETI as an IR
instruction (created in handle_possible_exit_DC()) to get the value of
the FPU stack top during execution instead of grabbing it ourselves.


Ok, the biggest problem right now is that floating point stuff doesn't
work correctly :(


Also, it doesn't properly handle command-line options :(

While we're busy porting/refactoring, get rid of Demsky's
GenericHashtable and use Valgrind's own hash table.  Also, try to
abstract out Fjalar stuff using function pointers/stuff?


----------
2005-04-29
----------

Ok, command-line options and floating-point have been fixed quite
easily by fixing my stupid typos.  Now the V-bits on the
floating-point stack still don't seem to be working correctly.  I will
investigate right now.

extern void *VG_(shadow_alloc)(UInt size); <--- Hmmm, should I use
this to allocate all of my junk?


Ok, my problem now is to try to get A and V bits working for EAX, EDX,
and FPU because I don't want to have special 'overrideIsInitialized'
handling for them 'cause that's lame.  Copying A/V-bits over to
virtualStack seems to work, but not for registers in the guest state.
Gotta investigate further ...

The question now becomes ... does Memcheck do A/V-bit tracking on
Kvasir's own C code?  Or does it only do tracking on client code?
Like what if I pass pointers to local variables (in Kvasir functions)
around?  Do these get associated A and V-bits?  I'm starting to doubt
it :(

Ok, it seems like the EAX/EDX shadow bits are working great, but the
FPU shadow bits are way the hell off.  I've gotta investigate that.
* Ok, done.  It was a stupid '&' typo in coregrind/vg_main.c

----------
2005-05-01
----------

Wow, really good news!  It seems that when I run the Kvasir tests with
Kvasir_DC (Kvasir + DynComp), I get a lot better results for
floating-point values.  Whereas before, some of them would print out
as 'uninit', now they print out as their real values!

Hmmm ... we still don't seem to be getting the validity of array
contents correctly for stuff in the bc regression test, but I'll
ignore that for now.


----------
2005-05-03
----------

Ok, it's time to start implementing the variable comparability stuff.

For the purposes of comparability, we need to keep 'variables' for all
the Daikon-derived crap, but we don't have DaikonVariable entries for
all of them.  This means that as we traverse through stuff during the
.decls run, we need to build up a mapping of variables (referenced
purely by *strings* since DaikonVariable entries are not unique up to
pointer dereference levels) to uf_objects.


Ok, I am still struggling to understand Stephen's algorithm.  I know
that outputDtraceValue() needs to be augmented to take in some more
stuff, but I'll think more about it tomorrow.


----------
2005-05-04
----------

Umm, when we observe variable values in dtrace-output.c, what if the
variable in unallocated or uninitialized?  I assume that we just skip
it and leave its tag as 0 for this particular instance of the program
point.

Look into doing less merges in dtrace-output.c because we shouldn't
merge when we don't need to.  For the example of outputting 4-byte
ints, those tags should already be merged when reading them out of
registers and into memory, right?

Hmmm, the return values have a tag of 0, which is strange.  Ahhh,
perhaps they are not shadows properly with tags - ok, fixed now!


Ok, question about hashing.  Does it matter what number we mod ('%')
the size by?  I mean, the size of the hash table does change, right?
So which number is good for the hash function?  Or does it not matter
because GenericHashtable will mod it for us?  Oh, haha, it does mod it
for us :) So don't worry about modding ourselves!


----------
2005-05-05
----------

Notes from meeting with Stephen:


Using tags as Daikon comparability numbers
------------------------------------------

Can use use the tags as Daikon comparability numbers in the .dtrace
file?  I guess so.  If we're afraid of the tags being too big, just
subtract everything by the smallest tag ever observed :)  Yes, but BE
CAREFUL about large numbers.  The tags are UInts but Daikon represents
comparability numbers as signed ints (Stephen thinks so).

If we're afraid that there are too many tags in existence, we could
really just subtract all tags at EACH program point by the smallest
one AT THAT program point.  This will mean that there are
comparability number duplications across program points, but Daikon
doesn't really care at all.


Future research question
------------------------

Once we get a good working prototype and are able to evaluate its
results, consider refining the algorithm to provide more precise
information.  Currently, we are restricted by the fact that the
variable comparability sets are always supersets of the value
comparability sets.  This makes the implementation much easier and
cleaner, but may result in coarser-grained info. (which may or may not
be a bad thing in practice).  However, assuming that we don't make the
assumption that var. sets and supersets of value sets, then how could
we implement this efficiently without keeping around too much info. and
doing post-processing (which is unreasonable).  We need an on-the-fly
algorithm to create finer partitions.  However, it doesn't matter for
now because we just want a prototype which works.


The current algorithm explained
-------------------------------

SMcC's current algorithm for propagating value comparability to
variable comparability sets at each program point (annotated by
pgbovine)

Each program point has its own copy of the following data structures:

var_uf_map:
Key: tag which is the leader of some entry in val_uf
Value: uf_object

Define a function (implemented as a non-null hashtable get)
var_uf_map.exists(val_uf leader entry) returns true if entry from
val_uf exists in var_uf_map.

var_uf_map is the variable analogue to val_uf, which is the union-find
for all values ever created in a program.

var_tags: A fixed-sized array (indexed by the serial # of Daikon
variables at that program point) which contains tags which are the
leaders of the comparability sets of their value's tags at that
program point.

new_tags: A fixed-sized array (also indexed by # of Daikon variables)
of the tags extracted by a certain Daikon variable's value at this
program point.  This structure is updated EVERY TIME the program
executes a program point by querying val_uf with the address of the
variable's value being observed and getting back the tag.

The size of var_tags and new_tags can be initialized during the .decls
run because we can count up how many Daikon variables exist at that
program point.  The number of Daikon variables as well as their order
is maintained during all program point executions in the .dtrace run
because the same traversal function is executing for both .decls and
.dtrace (and more importantly, because Daikon expects the front-end
output to maintain these variables in the same order).


Pseudo-code of the conversion from value to variable comparability
which occurs at every program point:

for each variable indexed by v {
  // Update from any val_uf merges that have occurred for variables on
  // previous executions of this program point.

  // Make sure that the degenerate behavior of this line is that it
  // returns 0 so we don't do anything when there's no previous info.
  // to update
  tag leader = val_uf.find(var_tags[v]);
  if (leader != var_tags[v]) {
    var_tags[v] = var_uf_map.union(leader, var_tags[v]);
  }


  // Make sure that an entry is created in var_uf_map for the tag
  // associated with the new value that we observe from the
  // memory-level layer
  tag new_leader = val_uf.find(new_tags[v]);
  if (!var_uf_map.exists(new_leader)) {
    var_uf_map.insert(new_leader, make_set(new uf_object));
  }

  // Merge the sets of all values that were observed before for this
  // variable at this program point with the new value that we just
  // observed
  var_tags[v] = var_uf_map.union(var_tags[v], new_leader);
}

Notice that val_uf is NEVER modified, only observed.  This is crucial
in keeping the separation in layers between the variable (language)
and value (memory) levels.  The concept is that tags may be merged at
the variable level without being merged at the value level.


Ok, remember to change this to something useful if we want Daikon to
use comparability information:

  fputs("VarComparability\nnone\n\n", decls_fp);



Remember that we have to make one more pass at the VERY END of
execution to account for actual argument interactions which occur
AFTER all instances of the point have finished executing.  At the
sweep in the end, we really don't have a valid address to use for any
variables so we are not producing any new tags in the variable
comparability sets.  We are merely reading the updated information
from val_uf and, I guess, executing only the first part of our
per-program-point-instance algorithm.



In FloatTest.c:

***EXIT returnIntSum - EBP=1388307368, lowestESP=1388307368
a (0)  new_tags[0]: 1409, new_leader: 1409, var_tags[0]: 1409
b (1)  new_tags[1]: 1409, new_leader: 1409, var_tags[1]: 1409
return (2)  new_tags[2]: 0, new_leader: 0, var_tags[2]: 0

Why does the return have a new_tags[2] of 0???  Look into the tags for
the return values.

I've isolated the problem in IntFromFloatTest.c.  It seems that there
is a problem because when you're casting from double to int, it
doesn't propagate the tags correctly.  This is likely to be a problem
with the memory-level tracking.

The offending function:

int returnIntSum(double a, double b)
{
  return a + b;
}

What IR instruction (or series of IR instructions) performs the
casting?


----------
2005-05-08
----------

SMcC's nifty trick to get inline C and assembly listings:

For every .c file:
Make .o file with gcc -c and debugging and -Wa,-aldhs
Pipe it to a file

e.g.
gcc -c -g IntFromFloatTest.c -Wa,-aldhs > IntFromFloatTest.S

It looks like it's doing some crazy-ass thing to convert double into
int, so maybe one of these steps isn't triggering an 'interaction':

   3:IntFromFloatTest.c ****   return a + b;
  26              		.loc 1 3 0
  27 0012 DD45F8   		fldl	-8(%ebp)
  28 0015 DC45F0   		faddl	-16(%ebp)
  29 0018 D97DEE   		fnstcw	-18(%ebp)
  30 001b 0FB745EE 		movzwl	-18(%ebp), %eax
  31 001f 660D000C 		orw	$3072, %ax
  32 0023 668945EC 		movw	%ax, -20(%ebp)
  33 0027 D96DEC   		fldcw	-20(%ebp)
  34 002a DB5DE8   		fistpl	-24(%ebp)
  35 002d D96DEE   		fldcw	-18(%ebp)
  36 0030 8B45E8   		movl	-24(%ebp), %eax


Ok, I see what the problem is (I think).  In
dyncomp_translate.c:expr2tags_Binop_DC(), we don't properly handle
floating-point to integer conversions (i.e. Iop_F64toI32) so we need
to add that handling right now.

Ok, I'm gonna try to make the .decls output with comparability.  This
will require us to output .decls at the END of execution:

We need to change this line from this:
  fputs("VarComparability\nnone\n\n", decls_fp);

to this:
  fputs("VarComparability\nexplicit\n\n", decls_fp);

or maybe just delete it altogether?

Daikon user manual:
"A comparability for a non-compound type is an integer. Comparisons
succeed exactly if either integer is negative or if both integers are
the same. ... If no information is supplied (i.e., this line is
blank), then the variable is compared to all other variables of the
same type."


----------
2005-05-09
----------

From SMcC's email:

"Also, I'm still a bit worried about the danger of having the wrong
behavior if any code tries to access one of the floating-point
registers with a plain GET or PUT. How hard would it be to put an
assertion in do_shadow_{GET,PUT}_DC() that would check the offset and
tell us if this is happening?"

I'll look into this later.


Hmmm ... this is unrelated, but it seems like I am merging stuff a bit
too aggressively.  In FloatTest, some things shouldn't have different
tags but do nonetheless.

It seems like the problems all come during the extra round of
propagations at the end, or with the fact that I'm not doing anything
for .dtrace values that were not observed, or the fact that we are
using integer literals (which have really tiny tags in the thousands)?

FloatTest.c:

  returnDoubleSum(1.2345, 4.321);
  returnInvalidInt(1.111, 2.222);

It seems that when the tags are merged for returnDoubleSum, the tags
for 'returnInvalidInt' are "infected" with the result from
returnDoubleSum.  Perhaps it has something to do with the virtualStack?

Make sure to clear tags as stack pointer moves up (done)

Ok, things seem to get better when I comment out all references to
val_uf_union_tags_in_range and val_uf_union_tags_at_addr.  What does
this mean?

Perhaps there are unnecessary merges (and transformations of tags into
canonical tags) when massive amounts of data are copied in a big chunk
over to different areas of memory.

Ok, what seems to solve the problem is to comment-out the
canonical-tag copying optimization in val_uf_union_tags_in_range,
which I probably did incorrectly.

Also, what solves the problem is cutting out all calls to
val_uf_union_tags_in_range only from dyncomp_main.c


Now I'm trying to update clear_all_tags_in_range() to actually destroy
the uf_objects associated with tags when the tags are killed.


Ahhh, ok, I may see what the problem is now.  After function entrance,
the tags are all merged and crap in the REAL stack, but we want to
observe crap on the VIRTUAL stack, where they aren't merged???  Hmmm?

Wait, but we ARE using the virtual stack.

-------------------------------------------------------------------
Ok, it seems like parallel mergings are happening under our nose in
the REAL stack due to the val_uf_union_tags_in_range calls in
dyncomp_main.c.  We should only do the mergings at the language-level
in dtrace-output.c when we observe values, not at the memory-level
in dyncomp_main.c.  That was a premature optimization so we should
just delete it.
-------------------------------------------------------------------


----------
2005-05-10
----------

Right now, DynComp can say that variables of different declared types
are comparable, but that's ok, right?  Because Daikon won't attempt to
compare variables of different types even though they have the same
comparability number.

It seems like the program-point-level granularity may be our downfall
because even if ONE instance of that program point was called with
comparable values, then we must report that the params are comparable.

Should we abandon the idea of the virtual stack altogether?

Ok, the only issue with abandoning virtual stack is that you sometimes
get inconsistencies since formal parameters are sometimes moved around
outside of their bounded area on the stack frame when calculations are
performed on them and stuff.  The reason why we used the virtualStack
idea was to ensure consistency.  All top-level parameters would be
taken from the state of the stack upon function ENTRY.

How important is this invariant to maintain?

(At least on small tests, it seems that the ints are well-behaved but
the doubles aren't.  The ints seem to maintain their spot on the
stack pretty well while the doubles don't.)

/********************************************************************
The fundamental problem here is that the compiler is free to
manipulate stuff around the stack as it sees fit after the function
begins executing.  I want some way of pinning down the parameters and
ensuring that they are ALWAYS located where the debugging info. says
that they are located on the stack relative to EBP.
********************************************************************/

Ok, so if we keep the virtualStack thing, then our results may look
weird but still consistent since we are always observing the pre-state
of the top-level Daikon variables.  The comparability sets for the
enter and exit will be identical for the entrance/exit because the
top-level VALUES are identical for both entrance/exit.


Hmmm, look at these interesting gcc 3.4.3 command-line option.  Maybe
this will help us eliminate duplication problems, especially for C++:

-feliminate-dwarf2-dups
    Compress DWARF2 debugging information by eliminating duplicated
information about each symbol. This option only makes sense when
generating DWARF2 debugging information with -gdwarf-2.

-feliminate-unused-debug-types
    Normally, when producing DWARF2 output, GCC will emit debugging
information for all types declared in a compilation unit, regardless
of whether or not they are actually used in that compilation
unit. Sometimes this is useful, such as if, in the debugger, you want
to cast a value to a type that is not actually used in your program
(but is declared). More often, however, this results in a significant
amount of wasted space. With this option, GCC will avoid producing
debug symbol output for types that are nowhere used in the source file
being compiled.


----------
2005-05-11
----------

There is currently no tag created for the '&' address-of operator, but
that may be okay because we really don't care about comparability for
pointers, only for the contents of pointers.


   9:PointerComp.c ****   inc(&x, yPtr);
  56              		.loc 1 9 0
  57 0043 8B45F8   		movl	-8(%ebp), %eax
  58 0046 89442404 		movl	%eax, 4(%esp)
  59 004a 8D45FC   		leal	-4(%ebp), %eax
  60 004d 890424   		movl	%eax, (%esp)
  61 0050 E8FCFFFF 		call	inc


Check out the LEA instruction which pushes &x onto the stack.  What
does this correspond to in IR?

However, malloc() seems to create a new tag.


Ok, we don't really compare hashcode values anyways, right?  So we
don't care?

Ok, a more serious problem.  We don't seem to be picking up relational
comparisons (<, >, =, <=, >=) as interactions :( Let's take a look at
the assembly sometime.

Haha, whoops, there are tons of comparison operations in IR! hehe

Ok, now all comparisons go thru as interactions :)

But ... logical AND, OR, and TERNARY should not qualify as
interactions because they can be thought of more as control flow:

  int c1 = 0, c2 = 1;

  if (c1 || c2) {
    logicalOr(c1, c2);
  }


This seems fine because c1 and c2 are ints.  But as soon as I change
them to chars, it looks like they have interacted.  Is this because
logicalOr() expects two ints and expands them to chars, somehow
mangling up their comparability sets?

Maybe everything on the stack is 4-byte aligned so it has to do
funny stuff to shrink it into 1-byte chars.  Perhaps we are getting an
inadvertent tag merging somewhere.  Both the 'int' and 'char' versions
do 'cmp against 0' instructions.

Hmmmm, even with all of the binary op. interactions turned off, it
still seems like those chars interact!  It has to be a memory-related
operation that's making them have the same tag.

Ummmm ... we have discovered a more fundamental problem - we don't
even need logical AND's/OR's, whatever.  'char'-sized things just
don't work.  DynComp thinks that there is an interaction between the
parameters of blank() when there is in fact none:

void blank(char a, char b) {}

int main() {
  char a = 'a';
  char b = 'b';

  blank(a, b);

  return 0;
}

Ok, I think I got the culprit.  For some reason, we are storing tags
for 4 bytes, which clobbers 4 bytes with the same tag, but then
reading only one byte at a time.  The 2 consecutive bytes will have
the same tag.  Tag 1787113 is the one which is shared by 'a' and 'b',
but should not be.

helperc_STORE_TAG_4(0x52BFE3B6, 1787113) [nextTag=1787114]
helperc_LOAD_TAG_1(1388307382) = 1787113 [nextTag=1787116]
helperc_STORE_TAG_4(0x52BFE3A4, 1787113) [nextTag=1787118]
helperc_LOAD_TAG_1(1388307383) = 1787113 [nextTag=1787120]
helperc_STORE_TAG_4(0x52BFE3A0, 1787113) [nextTag=1787121]
***ENTER blank at EBP=1388307352, lowestESP=1388307356, startPC=0x8048354
a (0)  new_tags[0]: 1787113, new_leader: 1787113, var_tags_v (old): 0, var_tags[0]: 1787113 (a: 2970941008)
b (1)  new_tags[1]: 1787113, new_leader: 1787113, var_tags_v (old): 0, var_tags[1]: 1787113 (a: 2970941012)

Ok, one simple solution is to be conservative and ALWAYS set the tag
for only 1 byte at at time.  Thus, for a helperc_STORE_TAG_4 of tag X
at addr A, we get:

A    : X
A + 1: ?
A + 2: ?
A + 3: ?

This leaves the rest of the bytes alone so they take whatever tags they
had originally.  I'm kind of wary of this because we don't want
'leftovers' from previous tags.

or we could set the tag for the first byte and create NEW tags for the
rest:

A    : X
A + 1: new1
A + 2: new2
A + 3: new3

This will allow the language layer to merge them only when we actually
have confirmed that we want to read all 4 bytes togther as an int.
This seems like a decent solution, although it's wasteful because we
are creating new tags without creating new values.  This kind of
breaks the semantics of new-value -> new-tag.

or set all other bytes to 0 explicitly:

A    : X
A + 1: 0
A + 2: 0
A + 3: 0

This may be bad because 0 is associated with 'invalid' V-bits.

But none of these solutions are truly satisfying.


Ok, this is weird.  Vex generates a STORE_TAG_4 for a non-4-byte
aligned address:

***ENTER blank at EBP=1388307352, lowestESP=1388307356, startPC=0x8048354
a (0)  new_tags[0]: 1787113, new_leader: 1787113, var_tags_v (old): 0, var_tags[0]: 1787113 (a: 2970941008)
b (1)  new_tags[1]: 1787113, new_leader: 1787113, var_tags_v (old): 0, var_tags[1]: 1787113 (a: 2970941012)
helperc_LOAD_TAG_4(1388307360) = 1787113 [nextTag=1787131]
helperc_LOAD_TAG_4(1388307364) = 1787113 [nextTag=1787133]
helperc_STORE_TAG_4(1388307351, 1787113) [nextTag=1787135]
helperc_STORE_TAG_4(1388307350, 1787113) [nextTag=1787137]
helperc_LOAD_TAG_4(1388307352) = 1787113 [nextTag=1787138]


We should really be doing STORE_TAG_1 in these places.

FIXED!!!  The problem was that we were using the tag byte size to
find out which STORE to all, and the tag byte sizes are always 4.
However, it worked fine for Memcheck V-bits because the V-bit sizes
are always the same as the real byte sizes.



Do more testing with different integral sizes!


Questions to ask Stephen for tomorrow's meeting:

1.) Setting up an end-to-end test framework for comparability numbers:
Do something easily diff-able.  Put comparability sets on separate
lines underneath their program point names.

2.) Should we still use the virtual stack or not?  I say yes. Definitely
YES

3.) Address Stephen's email about assertions for the GET's
DONE!

4.) Try to find some way to dump the IR listing for a compiled binary
Call ppIRBB()

5.) How to solve the issue with char's being comparable when they
shouldn't be?
FIXED - remember that tags are always 4-bytes so don't cue off their
sizes to do anything.  We used to cue off of the tag's sizes and
always ended up calling STORE_TAG_4, but we should really cue off the
size of the REAL data.

6.) Run by the idea of not passing along tags to the results of binary
comparison operations
YES, WE AGREE!

----------
2005-05-12
----------


I really want to find a way to dump all the IR generated by a program,
kind of like how I can dump the assembly listing.  This way, I can
compare assembly and IR.

	Solution: Use ppIRBB()!!!


IDEA!  Should comparisons only merge the sets of their two arguments
but NOT pass on one of the tags as the result?  That is, in:

x = (a < b)

We merge the tags of 'a' and 'b' but don't pass the tag of either one
to 'x'.  Instead, 'x' gets a tag of 0.  After all, 'x' is really just a
boolean '0' or '1' without any interesting semantic meaning.  Thus, if
we have (a < b) || (c < d), then we have {a, b} {c, d} like we want,
without any possibilities of {a, b, c, d} clumping.  Of course, the
logical AND/OR should not merge tags, but I found that with
'char'-sized things, they do for some reason.

The only reason why you would want to pass along the tag to the result
is so that you can have correct behavior on nested expressions (like (a
+ ((b - c) * d))), but you never really nest comparisons, right?

You don't do ((a < b) > c) or anything like that since the result of a
comparison is a 0 or 1 which really can't be compared with other stuff.

On an unrelated note, there seems to be a lot of tag merging going on
after the exit of main(), which may take up a lot of time and may or
may not be helpful at all.  I guess we must keep them in the interest
of 'full program coverage', though.




------------------------------------------------
Towards automated unit testing of comparability:


We want something which is easy to diff:

Do a post-processing step on the .decls file to generate a new file.

At each program point, there would be one line per comparability set
of variables, sorted by name.

This way, you could easily do diffs.

e.g.

foo():::ENTER
a, b
c
foo():::EXIT
a, b
c
return
------------------------------------------------


-------------------------------
Prettier comparability numbers:

Perhaps have a separate set of serial comparability number 'tags' for
variable-level union finds, but this isn't crucial at this point.  As
new union-find objects are added to var_tags, associate serial
comparability numbers to each one of them (similar to how we associate
serial tags).  That way, we can get a much tighter and smaller group
of comparability sets
-------------------------------



Problem:

  double doubleA = 10.231;
  float floatB = 10.234;

  if (doubleA < floatB) {
    lessThanFloat((float)doubleA, floatB);
  }

It says that the first parameter in lessThanFloat has a tag of 0.  Bad
bad bad!  This same problem happens to doubles elsewhere too.  Uh oh!
Ummm, FloatTest just breaks entirely now.

Ok, it seems like fixing the previous bug with the STORE_TAG_4's
screwed up floating-point stuff for some reason.


Look at the CVS log for dyncomp_main.c:

--------------------------------------------------------
revision 1.9
date: 2005-05-09 21:27:02 +0000;  author: pgbovine;  state: Exp;  lines: +36 -28
deleted the val_uf_union_tags_in_range() call in dyncomp_main.c
because that's incorrect.  We only want to do clumping merges on the
LANGUAGE-LEVEL when we observe variables.

This became a problem because the LANGUAGE-LEVEL manipulates the virtual
stack while the memory-level manipulates the real stack.
--------------------------------------------------------

I've put the val_uf_union_tags_in_range() calls BACK IN ...
The reason why we deleted those lines in the first place during
LOAD_TAG's was because they were interfering with the real/virtual
stack setup.  That might have been a red herring, though, but keep
that in the back of my mind as one potential problem.


Use objdump -d on the executable to get the offsets after linking so
that we can match it up with the output from ppIRBB()


Uhh, with the FloatTest not working problem, if we shift things so
that both

   case Ity_F64:
   case Ity_F32:

go to MC_(helperc_STORE_TAG_4), things seem to work, but this is
highly unsatisfying :(


Uhhhh ... for some strange reason, we need:

VGA_REGPARM(1)
void MC_(helperc_STORE_TAG_8) ( Addr a, UInt tag ) {

REGPARM(1) on the STORE_TAG_8, and that seems to fix it.  Super weird.



It seems like < and <= are regular comparisons but for some reason, >
and >= are handled by clean helper calls, thus leading in an asymmetry
of tag handling for comparisons.

Solution: In handleCCall_DC(), always return a tag of 0.  It seems
like the only call to this is for '<' and '<=' so far.  Revise this
later if necessary.


----------
2005-05-16
----------

Ok, one problem I see is that structs have the same comparability sets
as their first members.  This is caused by the fact that the struct
itself is located at the same location as the first member.  However,
our convention is to print out the struct name like a hashcode, so it
is BAD if we compare hashcode values with the first member.  However,
this may not be a big deal since Daikon doesn't compare two variables
with different Daikon types (i.e. hashcode and int) anyways, right?

Our current .comp format doesn't show which variables are comparable
to one another in the degenerate case when their comparability numbers
are -1.  Perhaps we should create a special set for that so that it's
more evident to the observer.  A variable has a comparability number
of -1 either when it has never been observed or it has always been
'uninit' when observed.  Thus, it is comparable to all other variables
at that program point, but that doesn't matter since it never had a
valid value for Daikon to infer invariants over anyways.
