DynComp Dynamic Comparability Analysis development notes
by Philip Guo

----------
2005-04-12
----------

When I run dyncomp on 'date' and Memcheck on 'date', dyncomp gives a
lot more uninitialized value warnings.  Memcheck seems to generate
these similar warnings but suppresses them.

dyncomp:
...
==24247== Conditional jump or move depends on uninitialised value(s)
==24247==    at 0x1B8ED585: _dl_relocate_object (in /lib/ld-2.3.2.so)
==24247==    by 0x1B8E6098: (within /lib/ld-2.3.2.so)
==24247==    by 0x1B8F30FC: (within /lib/ld-2.3.2.so)
==24247==    by 0x1B8E4F3A: (within /lib/ld-2.3.2.so)
==24247==    by 0x1B8E4C26: (within /lib/ld-2.3.2.so)
==24247==
==24247== Conditional jump or move depends on uninitialised value(s)
==24247==    at 0x1B8ED3DA: _dl_relocate_object (in /lib/ld-2.3.2.so)
==24247==    by 0x1B8E60DF: (within /lib/ld-2.3.2.so)
==24247==    by 0x1B8F30FC: (within /lib/ld-2.3.2.so)
==24247==    by 0x1B8E4F3A: (within /lib/ld-2.3.2.so)
==24247==    by 0x1B8E4C26: (within /lib/ld-2.3.2.so)
==24247==
==24247== Conditional jump or move depends on uninitialised value(s)
==24247==    at 0x1B8ED3E8: _dl_relocate_object (in /lib/ld-2.3.2.so)
==24247==    by 0x1B8E60DF: (within /lib/ld-2.3.2.so)
==24247==    by 0x1B8F30FC: (within /lib/ld-2.3.2.so)
==24247==    by 0x1B8E4F3A: (within /lib/ld-2.3.2.so)
==24247==    by 0x1B8E4C26: (within /lib/ld-2.3.2.so)
==24247==
==24247== Conditional jump or move depends on uninitialised value(s)
==24247==    at 0x1B8ED585: _dl_relocate_object (in /lib/ld-2.3.2.so)
==24247==    by 0x1B8E60DF: (within /lib/ld-2.3.2.so)
==24247==    by 0x1B8F30FC: (within /lib/ld-2.3.2.so)
==24247==    by 0x1B8E4F3A: (within /lib/ld-2.3.2.so)
==24247==    by 0x1B8E4C26: (within /lib/ld-2.3.2.so)
Tue Apr 12 16:25:24 EDT 2005
==24247==
==24247== ERROR SUMMARY: 20 errors from 8 contexts (suppressed: 0 from 0)
==24247== malloc/free: in use at exit: 6186 bytes in 42 blocks.
==24247== malloc/free: 47 allocs, 5 frees, 8051 bytes allocated.
==24247== For counts of detected errors, rerun with: -v
==24247== searching for pointers to 42 not-freed blocks.
==24247== checked 415748 bytes.
==24247==
==24247== LEAK SUMMARY:
==24247==    definitely lost: 0 bytes in 0 blocks.
==24247==      possibly lost: 0 bytes in 0 blocks.
==24247==    still reachable: 6186 bytes in 42 blocks.
==24247==         suppressed: 0 bytes in 0 blocks.
==24247== Reachable blocks (those to which a pointer was found) are not shown.
==24247== To see them, rerun with: --show-reachable=yes


Memcheck:

Tue Apr 12 16:25:51 EDT 2005
==24386==
==24386== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 20 from 1)
==24386== malloc/free: in use at exit: 6186 bytes in 42 blocks.
==24386== malloc/free: 47 allocs, 5 frees, 8051 bytes allocated.
==24386== For counts of detected errors, rerun with: -v
==24386== searching for pointers to 42 not-freed blocks.
==24386== checked 415748 bytes.
==24386==
==24386== LEAK SUMMARY:
==24386==    definitely lost: 0 bytes in 0 blocks.
==24386==      possibly lost: 0 bytes in 0 blocks.
==24386==    still reachable: 6186 bytes in 42 blocks.
==24386==         suppressed: 0 bytes in 0 blocks.
==24386== Reachable blocks (those to which a pointer was found) are not shown.
==24386== To see them, rerun with: --show-reachable=yes


Notice that Memcheck suppressed 20 warnings but dyncomp didn't.  This
is weird because I've copied dyncomp over from Memcheck and only
changed its name.  Oh well ... maybe the Memcheck developers
suppressed certain errors which only match up with something that's
dependent on the Memcheck name.  This is probably not a big deal since
we don't care about leak checking anyways.


----------
2005-04-13
----------

/* Allocate a new shadow for the given original tmp.  This means any
   previous shadow is abandoned.  This is needed because it is
   necessary to give a new value to a shadow once it has been tested
   for undefinedness, but unfortunately IR's SSA property disallows
   this.  Instead we must abandon the old shadow, allocate a new one
   and use that instead. */
static void newShadowTmp ( MCEnv* mce, IRTemp orig )

In (mc_translate.c):
Check this out.  One of the first problems I need to solve is how
Memcheck automatically sets a byte to defined after it has been tested
for undefinedness in order to avoid propagating errors.  We need to
disable this functionality.


/* Check the supplied **original** atom for undefinedness, and emit a
   complaint if so.  Once that happens, mark it as defined.  This is
   possible because the atom is either a tmp or literal.  If it's a
   tmp, it will be shadowed by a tmp, and so we can set the shadow to
   be defined.  In fact as mentioned above, we will have to allocate a
   new tmp to carry the new 'defined' shadow value, and update the
   original->tmp mapping accordingly; we cannot simply assign a new
   value to an existing shadow tmp as this breaks SSAness -- resulting
   in the post-instrumentation sanity checker spluttering in disapproval.
*/
static void complainIfUndefined ( MCEnv* mce, IRAtom* atom )

From the Memcheck user's manual (mc_main.html):
If a check should detect undefinedness, an error message is
issued. The resulting value is subsequently regarded as
well-defined. To do otherwise would give long chains of error
messages. In effect, we say that undefined values are non-infectious.


I think that commenting out all the complainIfUndefined() calls in
mc_translate.c should do the trick.



/*------------------------------------------------------------*/
/*--- Generate shadow values from all kinds of IRExprs.    ---*/
/*------------------------------------------------------------*/

static
IRAtom* expr2vbits_Binop ( MCEnv* mce,
                           IROp op,
                           IRAtom* atom1, IRAtom* atom2 )

This huge function seems to generate the shadow values for all sorts
of expressions.  Perhaps this is what I should hack on.

The ENSURE_MAPPABLE(addr,caller) macro in mac_shared.h seems to be the
only thing that calls alloc_secondary_map() to allocate a new
secondary map if the current one for the address addr is distinguished
(uninitialized and/or unallocated).


----------
2005-04-14
----------

The best way is to eliminate the tags from the memcheck structures
and just have our own (because their optimization messes us up)

When do we have instructions which create a new value in memory?

Tags are associated with valid V-bits - tags are needed for a byte
when at least 1 V-bit in your byte is valid.  V-bits get set when you
overwrite stuff.  We want to destroy old tag and move a new one in
when none of the original data can be recovered

Globals:
Every byte needs a new unique tag upon program instantiation
There is probably some special case for this

set_address_range_perms is probably what sets all the global area to A
and V; need to do similar things with tags

Stack:
Local variables - upon function entrance, moves ESP down a whole chunk
at a time

int x = 10;
x = 6;
int y = 15;

In x86, you can either have '10' write to a register then write the
register into memory, or have an instruction that directly writes '10'
into memory.  But the important thing to note is that the creation of
the literal '10' is what creates the tag and moves it into either
register or memory.  We need tags associated with registers as well as
memory.

IR is maybe some kind of expression tree which implicitly assigns
names to stuff -

(Maybe) Memcheck must somehow make a new parallel expression tree for
A/V-bits

mc_translate.c

temps
newShadowTmp()?

shadowing - given the tree for the actual expressions, give me the
corresponding one for the V-bits (A-bits don't have to do with
operations, only on memory allocation)

PUT/GET :: STORE/LOAD


expr2vbits_Binop() - the tree-walk which builds up the parallel trees

We start with x86 -> IR tree and then walk it to build up a v-bit tree

Input tree is probably fairly linear but we want a tree representation

IR has two levels - statements and atoms (expressions)

         case Ist_Tmp:
            assign( bb, findShadowTmp(&mce, st->Ist.Tmp.tmp),
                        expr2vbits( &mce, st->Ist.Tmp.data) );
            break;

This seems to be the meaty call

We need some instructions to write to tags just like how they write
instructions to write A and V bits


/* Generate a shadow store.  addr is always the original address atom.
   You can pass in either originals or V-bits for the data atom, but
   obviously not both.  */

static
void do_shadow_STle ( MCEnv* mce,
                      IRAtom* addr, UInt bias,
                      IRAtom* data, IRAtom* vdata )

We need vars to keep track of tags - we need store and load tag
operations in mc_translate.c

We need helpers for store tag, load tag, and merge-two-tags

When we do 32-bit operations, we should just unify them into one tag

LOAD is an expression whereas STORE is a statement

STORE has to be a statement because it has side effects (you can swap
a LOAD/STORE or two STOREs)

Input from the user is conceptually a place where you get new data

If you do ESP + 1, you need to get a new tag because of &-operators

We seem to need a parallel tmpMap

We need to create parallel helper functions to deal with tags:
VGA_REGPARM(1)
UInt MC_(helperc_LOADV1) ( Addr a )



static
void mc_new_mem_startup( Addr a, SizeT len, Bool rr, Bool ww, Bool xx )

static
void mc_new_mem_heap ( Addr a, SizeT len, Bool is_inited )

static
void mc_new_mem_mmap ( Addr a, SizeT len, Bool rr, Bool ww, Bool xx )


We may be able to mc_new_mem_heap to create tags and stuff
and zero stuff out when stack pointer moves


We have two problems to solve:

The easy one: Statically-initialized things - we can simply plug stuff
into mc_main.c.

The hard one: Dynamic events - we need to actually instrument the IR
and do funky stuff.


Do we need any special handling of malloc() and friends?


What do we do with init_new_mem_stack, init_die_mem_stack and friends?


----------
2005-04-17
----------

I turned on 'verboze' in mc_translate.c:TL_(instrument) and diff'ed
two versions of SuperSimpleTest, one with an extra 'int z = x + y;'
statement and here was the main difference:

------ IMark(0x8048375, 3) ------


PUT(56) = 0x8048375:I32


t33 = Add32(t23,0xFFFFFFFC:I32)

   t75 = Or32(t45,0x0:I32)
   t76 = Sub32(0x0:I32,t75)
   t77 = Or32(t75,t76)
   t78 = t77

t15 = LDle:I32(t33)

   t79 = DIRTY 1:I1 RdFX-gst(16,4) RdFX-gst(56,4) ::: MC_(helperc_LOADV4)[rp=1]{0xB125FDF7}(t33)
   t80 = t79

t14 = Add32(t32,t15)

   t81 = Or32(t74,t80)
   t82 = Sub32(0x0:I32,t81)
   t83 = Or32(t81,t82)
   t84 = t83

PUT(32) = 0x3:I32


PUT(36) = t32

   PUT(348) = t74

PUT(40) = t15

   PUT(352) = t80

PUT(44) = 0x0:I32


------ IMark(0x8048378, 3) ------


PUT(56) = 0x8048378:I32


t35 = Add32(t23,0xFFFFFFF4:I32)

   t85 = Or32(t45,0x0:I32)
   t86 = Sub32(0x0:I32,t85)
   t87 = Or32(t85,t86)
   t88 = t87

STle(t35) = t14

   DIRTY 1:I1 RdFX-gst(16,4) RdFX-gst(56,4) ::: MC_(helperc_STOREV4)[rp=2]{0xB125FE46}(t35,t84)



Look in do_shadow_STle:

See the 'void* helper' local variable?  We need to somehow hijack this
one so that we can call our own nifty helper functions at certain
instructions.  From my observation, what Memcheck does is create new
IR trees which contain primitive operations (i.e. AND, OR) on the
V-bits, but there are no primitive operations for "merge tags"
et. al. so that we need to simply suck it up and call our own helper
functions. (Check out setHelperAnns(), unsafeIRDirty_0_N(),
unsafeIRDirty_1_N())

/vex/pub/libvex_ir.h contains some useful IR definitions

IRCallee seems to describe a helper function to call
mkIRCallee(), dopyIRCallee(), etc...

IRExpr_CCall is for pure (no side effects) helper functions whereas
IRStmt_Dirty is for non-pure ones

If you make a dirty call, you must specify EXACTLY which memory areas
you are going to affect, etc...

We definitely need to use tmps to make copies of tags as they flow
from place-to-place.  Otherwise, when there is an operation which
involves two registers (i.e. ADD R1 R2), we have no clue about the
tags of R1 and R2


Super ghetto solution - make a copy of all of the Memcheck
instrumentation code and DUPLICATE it for tags.  Then modify
TL_(instrument) to create BOTH tag and A/V-bit-manipulation
instructions for all inputted instructions


***
What do we do when we read multiple bytes from memory?  Do we merge
the tags associated with all of these bytes and just return one tag?
That seems like it may lose some precision but it's just much easier
to implement (at least for now).
***

helperc_STORE_TAG_4(0x52BFE3BC, 0) [nextTag=110593]
helperc_STORE_TAG_4(0x52BFE3B8, 0) [nextTag=110593]
helperc_STORE_TAG_4(0x52BFE3B4, 0) [nextTag=110593]
helperc_STORE_TAG_4(0x52BFE3B0, 0) [nextTag=110593]
helperc_STORE_TAG_4(0x52BFE3AC, 0) [nextTag=110593]
helperc_STORE_TAG_4(0x52BFE35C, 0) [nextTag=110593]
helperc_LOAD_TAG_4(0x52BFE35C) = 0 [nextTag=110593]
helperc_LOAD_TAG_4(0x52BFE35C) = 0 [nextTag=110593]
helperc_STORE_TAG_4(0x52BFE388, 0) [nextTag=110593]
helperc_LOAD_TAG_4(0x1B8FAC00) = 101377 [nextTag=110593]
helperc_STORE_TAG_4(0x1B8FA66C, 4294967295) [nextTag=110593]   <---- PROBLEM!!!
helperc_STORE_TAG_4(0x1B8FA674, 4294967295) [nextTag=110593]   <---- PROBLEM!!!
helperc_STORE_TAG_4(0x52BFE380, 0) [nextTag=110593]
helperc_LOAD_TAG_4(0x52BFE380) = 0 [nextTag=110593]
helperc_STORE_TAG_4(0x52BFE384, 0) [nextTag=110593]
helperc_LOAD_TAG_4(0x1B8FA674) = 4294967295 [nextTag=110593]   <---- PROBLEM!!!

Look at big-output.pid2528 to see the results of the loads and store
helper function calls: Ummm, there is this mystery garbage value
(4294967295, which is 0xffffffff) likely caused by a bogus store ...
which means that we are storing garbage, which ain't good.

Also other weird garbage values: 4294967280 (0xfffffff0)

I'm trying to get rid of these!!! (Really bad hack - check store
tag values to make sure that they are below 'nextTag', but this is a
bad way to patch up the problem.)

I probably need to clean up the rest of the DynComp code before going
back to this.  Perhaps the rest of the incompatibilities are causing
these bogus values to be stored.  It's still too early to get to the
bottom of this problem.


----------
2005-04-20
----------

Ok, got rid of the garbage values (by disabling handling of unary ops)
and started getting something to work with MERGE_TAGS, except that the
second tag parameter is ALWAYS 0.  That's no good :(

e.g.

helperc_STORE_TAG_4(0x52BFE354, 101913) [nextTag=1466035]
helperc_MERGE_TAGS_4(101913, 0) [nextTag=1466035]
helperc_STORE_TAG_4(0x52BFE350, 110758) [nextTag=1466035]
helperc_MERGE_TAGS_4(101913, 0) [nextTag=1466035]
helperc_STORE_TAG_4(0x52BFE34C, 0) [nextTag=1466035]


!!! Ok, I may have some insight into the problem ... we are using
definedOfType_DC() as a cop-out to create a 0-valued tag, which seems
to clobber the hell out of a lot of valid tag values.  What I really
want is something like a no-op. !!!


----------
2005-04-21
----------

Difference between Put and STle?

      Ist_NoOp,   /* no-op (usually resulting from IR optimisation) */
      Ist_Put,    /* write guest state, fixed offset */
      Ist_PutI,   /* write guest state, run-time offset */
      Ist_Tmp,    /* assign value to temporary */
      Ist_STle,   /* little-endian write to memory */

Look at Ist_NoOp!
extern IRStmt* IRStmt_NoOp

/* Convenience function for constructing clean helper calls. */
IRExpr* mkIRExprCCall

Stephen's suggestions from our meeting today:

Ideally, we want to somehow replicate the tree structure of the
original IR except for the fact that our binary operations are merges.
Our merge operations should return the canonical tag of the merged
sets in the temporary so that it can be used further up the chain.
mkIRExprCCall can be our savior by providing a way to make a 'clean' C
function call as an IRExpr, which can fit in our parallel IR
expression tree.  E.g.

    (sub)
    /  \
   /    \
 (add)  C
  / \
 /   \
 A   B

becomes ...

   (merge)
    /  \
   /    \
(merge) Ctag
  / \
 /   \
Atag Btag

Each (merge) merges the sets of the tags and returns the canonical tag
of the set so that it can be used in further merges.  This is very
important!

We need to try to use clean calls since they can fit in our expression
tree (hopefully) and not dirty calls because they are statements
(maybe?).



Ok, onto another issue ... optimization of tag mergings.  When we
union uf_objects pointed-to by tags, what we really want is to return
the tag of the canonical uf_object (the root of the tree) so that it
can be stored away.  This will help in garbage collection because it
ensures that we will have the smallest possible set of distinct tags
floating around at any one time.  Conceptually, we have two maps
(implemented as two-level sparse arrays):

tag_map: Addr --> tag
uf_object_map: tag --> uf_object

Whenever we perform a union of uf_objects in uf_object_map, we want to
also return the tag of the canonical (root) uf_object in the set.

Here is an example:

tag_map
-------
Addr:   1   2   3   4   5
tag:    10  20  30  40  50

uf_object_map
-------------
tag:        1 ... 10 ... 20 ... 30 ... 40 ... 50
uf_object:        A      B      C      D      E

Let's say you merge A, B, C, D, and E.  What we really want is to
return 10 (the tag of A) as the result of this merge.  That way, if we
assign the results of the merge into any new variable, it will show up
as 10.  So if we clobber addresses 2, 3, 4, and 5 with the results of
the merge, all of them will end up being 10 and we can garbage collect
tags 20, 30, 40, and 50.

To implement this with the two-level uf_object_map, we need to somehow
provide an efficient reverse mapping of uf_object --> tag.  My
suggestion is to keep a backpointer to the space in
primary_uf_object_map when you malloc each 2^16 secondary array of
uf_objects so that you can do a two-level pointer offset arithmetic to
get the tag, when given an uf_object*.

However, I want to defer the implementation of this optimization
because I don't see right off the bat how it will help us out too
much.  I want to have some more time to think about it first.

... ok, I thought about it.  It would be really helpful in the
helperc_LOAD_TAG... series of functions, where we are loading the tags
for several bytes (2, 4, or 8) and doing a union because we figure
heuristically that if you are reading 4 (or whatever) bytes from
memory, you really mean for those 4 bytes to have the SAME tag.  Right
now, we simply union the tags, but as a side effect, we should really
set the tags for all those relevant bytes to the CANONICAL (root)
tag.  In the above example, let's say that we were reading Addr 1, 2,
3, 4 as one block.  If 10 were the canonical tag for the union of A,
B, C, D, then we want to set the tags as follows:

tag_map
-------
Addr:   1   2   3   4   5
tag:    10  10  10  10  50

... which would allow tags 20, 30, and 40 to be garbage collected.

Ok, I'm now convinced that I should go thru with this optimization.


In order to simplify the implementation, I will just keep the 4-byte
tag along with each uf_object structure.  This wastes a bit of space,
bloating it from 8 to 12 bytes each, but it eliminates lots of
implementation complexities.


^^^^^^^^^^^^^^^^^^^^^^^^^^
Garbage collection idea!!!

When you're doing the mark-sweep garbage collection, clobber every
single tag with the canonical tag found using find_canonical_tag().
If we are pretty sure that there are relatively few distinct sets
(lots of merging occurs), then replacing each tag in shadow memory
(tag_map) with its canonical tag will better enable us to recycle
tags.
^^^^^^^^^^^^^^^^^^^^^^^^^^


Dude, something looks good:

SuperSimpleTest.c:

int main() {
  int x = 5;
  int y = 10;
  int z = x + y;
  printf("&x=%p, &y=%p, &z=%p\n", &x, &y, &z);
  return 0;
}


Program output:
&x=0x52bfe354, &y=0x52bfe350, &z=0x52bfe34c

Possibly an interesting part:

helperc_STORE_TAG_4(0x52BFE358, 0) [nextTag=1768769]
helperc_CREATE_TAG() = 1768769 [nextTag=1768770]
helperc_MERGE_TAGS_4(0, 1768769) [nextTag=1768770]
helperc_CREATE_TAG() = 1768770 [nextTag=1768771]
helperc_MERGE_TAGS_4(0, 1768770) [nextTag=1768771]
helperc_CREATE_TAG() = 1768771 [nextTag=1768772]
helperc_MERGE_TAGS_4(0, 1768771) [nextTag=1768772]
helperc_CREATE_TAG() = 1768772 [nextTag=1768773]
helperc_CREATE_TAG() = 1768773 [nextTag=1768774]
helperc_MERGE_TAGS_4(0, 1768773) [nextTag=1768774]
helperc_CREATE_TAG() = 1768774 [nextTag=1768775]             <-- create tag for '5'
helperc_STORE_TAG_4(0x52BFE354, 1768774) [nextTag=1768775]   <-- Assign '5' to x; tag(x) = 1768774
helperc_CREATE_TAG() = 1768775 [nextTag=1768776]
helperc_CREATE_TAG() = 1768776 [nextTag=1768777]
helperc_MERGE_TAGS_4(0, 1768776) [nextTag=1768777]
helperc_CREATE_TAG() = 1768777 [nextTag=1768778]             <-- create tag for '10'
helperc_STORE_TAG_4(0x52BFE350, 1768777) [nextTag=1768778]   <-- Assign '10' to y; tag(y) = 1768777
helperc_CREATE_TAG() = 1768778 [nextTag=1768779]
helperc_CREATE_TAG() = 1768779 [nextTag=1768780]
helperc_MERGE_TAGS_4(0, 1768779) [nextTag=1768780]
helperc_LOAD_TAG_4(0x52BFE350) = 1768777 [nextTag=1768780]   <-- Load y into register; tag(y) = 1768777
helperc_CREATE_TAG() = 1768780 [nextTag=1768781]
helperc_CREATE_TAG() = 1768781 [nextTag=1768782]
helperc_MERGE_TAGS_4(0, 1768781) [nextTag=1768782]
helperc_LOAD_TAG_4(0x52BFE354) = 1768774 [nextTag=1768782]   <-- Load x into register; tag(x)= 1768774
helperc_MERGE_TAGS_4(1768777, 1768774) [nextTag=1768782]     <-- Do 'x + y'; Merge tag(x) & tag(y)
helperc_CREATE_TAG() = 1768782 [nextTag=1768783]
helperc_CREATE_TAG() = 1768783 [nextTag=1768784]
helperc_CREATE_TAG() = 1768784 [nextTag=1768785]
helperc_CREATE_TAG() = 1768785 [nextTag=1768786]
helperc_MERGE_TAGS_4(0, 1768785) [nextTag=1768786]
helperc_STORE_TAG_4(0x52BFE34C, 1768777) [nextTag=1768786]   <-- Assign 'x + y' to z; tag(z) = tag(x) = 1768777



Uhhh, we still have lots of extraneous CREATE_TAG() calls without
being assigned to variables in memory, but the garbage collector
should take care of that.


----------
2005-04-22
----------

Stephen suggested that we count all binary ops as interactions
(because they all consist of data flow) unless otherwise noted
(e.g. shift operators, or operator, etc...).

z = x << y implies that z and x are comparable to one another, but not
to y.  That means that we simply copy the tag over from x to z and not
merge with the tag of y.

Some things shouldn't count as interactions at all (i.e. z = x || y)
so just pass along a 0 tag.


Ummm, now it barfs on ArrayTest with this error:

==5448==  Address 0x1BB3A000 is not stack'd, malloc'd or (recently) free'd
buffer population[999]: 134516768
buffer multiDimensional[4][5][12]: 0x804a720

vex: the `impossible' happened:
   genGuestArrayOffset(x86 host)
vex storage:  P 436,  T total 64171040 (1905138),  T curr 53956 (1654)

valgrind: the `impossible' happened:
   LibVEX called failure_exit().
==5448==    at 0xB0022A71: ???
==5448==    by 0xB0022A70: ???
==5448==    by 0xB0022A99: ???
==5448==    by 0xB0049C29: ???
==5448==    by 0xB0061561: ???
==5448==    by 0xB006ED5C: ???
==5448==    by 0xB0075A28: ???
==5448==    by 0xB0076114: ???
==5448==    by 0xB0060FE0: ???
==5448==    by 0xB004A1BA: ???
==5448==    by 0xB00136D7: ???
==5448==    by 0xB0013B17: ???

Basic block ctr is approximately 32990

sched status:
  running_tid=1

Thread 1: status = VgTs_Runnable
==5448==    at 0x80484CE: main (ArrayTest.c:96)


Ok, I'm trying to run dyncomp on the programs in the Kvasir test
suite.  This is all done with the CVS check-in at:
Fri Apr 22 16:03:55 EDT 2005

Or, in CVS time: 2005-04-22 20:04:56 +0000

Success:

bc
BinaryTreeTest
DisambigTest
Dstr
function-pointer
GlobalTest
inline-func
ManualDisambigExample
md5
MultiDimArrayTest
MultipleStructsTest
NestedStructTest
partial-init
pointer-levels
PointerTest
rijndael
shared-lib
SimpleDisambigStructTest
small-test
StackArrayCppTest
StackCppTest
StaticArraysTest
static-struct
string-arrays
StructPtrTest
tcas
two-statics
virtual-method

Failure (all with the genGuestArrayOffset(x86 host) problem):

ArrayTest
ArrayTest-cpp
ArraysInStructTest
crazy-test-1
TrivialTest
TypedefTest
TypesTest

Special failures:

IntTest

IN STATEMENT:

t325 = x86g_check_fldcw{0xB00838CA}(t73):I64

ERROR = IRStmt.Put.Tmp: tmp and expr do not match


vex: the `impossible' happened:
   sanityCheckFail: exiting due to bad IR
vex storage:  P 436,  T total 55547180 (1646556),  T curr 137076 (4325)



Now I need to figure out what exactly makes these programs fail and
generate the smallest possible example which reproduces this bug.

In TypesTest, if you remove the stuff which deals with doubles and
floats, it seems like you're fine:

    printf("returnDoubleSum(%f, %f) = %f\n",
	   (float)((a+b)/7),
	   (double)((2/b)*a),
	   returnDoubleSum((float)((a+b)/7), (double)((2/b)*a)));
    printf("returnFloatProduct(%f, %f) = %f\n",
	   (float)((b/9)+a*3.14159),
	   (float)(b*a+6/7*3),
	   returnFloatProduct((float)((b/9)+a*3.14159), (float)(b*a+6/7*3)));


I extracted this out into FloatTest under dyncomp-tests, which is a
tiny program that reproduces the genGuestArrayOffset() bug.

It seems like any conversion to a float triggers this error.


(On another note, all the Memcheck warnings we're getting with the
dyncomp-instrumented code - interestingly, only system calls - are
pesky.  Maybe something to do with helper functions, perhaps the dirty
ones messing up v-bits)


V-bits overriding problem:
The main problem here (we think) is that the shadow guest state is a
fixed size (the same size as the original guest state), which works
well for Memcheck, but not for us.  We need more space!!!


----------
2005-04-23
----------

Yeah, there is only one shadow guest state for Memcheck (too bad it's
hardcoded into Vex) and BOTH dyncomp AND Memcheck are sharing it,
which means that we are clobbering V-bit information in the guest
state (registers and stuff).  That's probably why we are getting so
many bogus Memcheck errors.  To solve this, we need to somehow
allocate more guest state.


Floating point crash:

int main() {
  unsigned int a = 10;
  float c = (float)a;
  return 0;
}

vex: the `impossible' happened:
   genGuestArrayOffset(x86 host)
vex storage:  P 436,  T total 58577752 (1707030),  T curr 107796 (3293)


But this works:

int main() {
  float c = 5;
  return 0;
}

Actually, this may be related to the floating-point crash because
getGuestArrayOffset() depends on the guest floating point array and if
the sizes are bogus, then we're screwed.

The problem is eliminated when you get rid of the handlers for Ist_PutI:

case Ist_PutI:
//            do_shadow_PUTI_DC( &dce,
//                               st->Ist.PutI.descr,
//                               st->Ist.PutI.ix,
//                               st->Ist.PutI.bias,
//                               st->Ist.PutI.data );
break;

It's got something to do with the indexing done in do_shadow_PUTI_DC.

From Iex_GetI ...
From Ist_PutI ...
From Ist_PutI ...

vex: the `impossible' happened:
   genGuestArrayOffset(x86 host)
vex storage:  P 436,  T total 58577752 (1707030),  T curr 107796 (3293)


Yep, the debug. output confirms something fishy in PUTI_DC.

Backtrace:

Breakpoint 2, genGuestArrayOffset (env=0xb0275a64, descr=0xb0269b3c, off=0x4,
    bias=-1) at priv/host-x86/isel.c:586
(gdb) bt
#0  genGuestArrayOffset (env=0xb0275a64, descr=0xb0269b3c, off=0x4, bias=-1)
    at priv/host-x86/isel.c:586
#1  0xb0075a59 in iselStmt (env=0xb0275a64, stmt=0xb0274c00)
    at priv/host-x86/isel.c:3295
#2  0xb0076145 in iselBB_X86 (bb=0xb026da38, subarch_host=123)
    at priv/host-x86/isel.c:3519
#3  0xb0060fe1 in LibVEX_Translate (arch_guest=VexArchX86,
    subarch_guest=VexSubArchX86_sse2, arch_host=2955336248,
    subarch_host=VexSubArchX86_sse2,
    guest_bytes=0x8048354 "U\211е\203м\b\203дрё", guest_bytes_addr=134513492,
    chase_into_ok=0x4, guest_extents=0xb0862ef4,
    host_bytes=0xb0259aa0 "\213\235L\001", host_bytes_size=20000,
    host_bytes_used=0x4, instrument1=0xb0046f44 <vgToolInternal_instrument>,
    instrument2=0xb004958e <vg_SP_update_pass>,
    cleanup_after_instrumentation=1 '\001', byte_accessible=0x4, traceflags=4)
    at priv/main/vex_main.c:492
#4  0xb004a1bb in vgPlain_translate (tid=1, orig_addr=134513492,
    debugging_translation=0 '\0', debugging_verbosity=0)
    at libvex_basictypes.h:151
#5  0xb00136d8 in handle_tt_miss (tid=1) at vg_scheduler.c:653
#6  0xb0013b18 in vgPlain_scheduler (tid=1) at vg_scheduler.c:768
#7  0xb005835d in vgArch_thread_wrapper (tidW=1) at core_os.c:41
#8  0x00000000 in ?? ()


This is the statement that it supposedly comes from:

(gdb) p *stmt
$7 = {tag = Ist_PutI, Ist = {NoOp = {<No data fields>}, IMark = {
      addr = 12692904998714383164, len = -1}, Put = {offset = -1339647172,
      data = 0xb02641d8}, PutI = {descr = 0xb0269b3c, ix = 0xb02641d8,
      bias = -1, data = 0xb0269ad8}, Tmp = {tmp = 2955320124,
      data = 0xb02641d8}, STle = {addr = 0xb0269b3c, data = 0xb02641d8},
    Dirty = {details = 0xb0269b3c}, MFence = {<No data fields>}, Exit = {
      guard = 0xb0269b3c, jk = 2955297240, dst = 0xffffffff}}}

pgbovine@parsnip:~/research/invariants/valgrind-3/vex$ grep -r x86guest_layout *
...
priv/guest-x86/gdefs.h:VexGuestLayout x86guest_layout;
priv/guest-x86/ghelpers.c:   x86guest_layout
priv/main/vex_main.c:         guest_layout     = &x86guest_layout;
...


pub/libvex_guest_x86.h:   VexGuestX86State;

pub/libvex.h: Check this out - it hardcodes the 2X size:
/* A note about guest state layout.

   LibVEX defines the layout for the guest state, in the file
   pub/libvex_guest_<arch>.h.  The struct will have an 8-aligned size.
   Each translated bb is assumed to be entered with a specified
   register pointing at such a struct.  Beyond that is a shadow
   state area with the same size as the struct.  Beyond that is
   a spill area that LibVEX may spill into.  It must have size
   LibVEX_N_SPILL_BYTES, and this must be a 16-aligned number.

   On entry, the baseblock pointer register must be 8-aligned.
*/

coregrind/x86/core_arch.h:      UChar vex_spill[LibVEX_N_SPILL_BYTES];

Here is where the shadow is FIXED!!!

typedef
   struct {
      /* --- BEGIN vex-mandated guest state --- */

      /* Saved machine context. */
      VexGuestX86State vex;

      /* Saved shadow context. */
      VexGuestX86State vex_shadow;

      /* Spill area. */
      UChar vex_spill[LibVEX_N_SPILL_BYTES];

      /* --- END vex-mandated guest state --- */
   }
   ThreadArchState;

Look at where the 2 is hardcoded! YUCK!

valgrind: vg_scheduler.c:484 (run_thread_for_a_while): Assertion `a_vex + 2 * sz_vex == a_spill' failed.


I'm changing it to add a vex_shadow_2 field to ThreadArchState.  Note
that this blows because I'll need to change it for EVERY architecture,
but that's ok since we're only doing x86 for now.

but now it segfaults :( bah


----------
2005-04-25
----------

We want to use 8-byte stores into guest state ONLY for PUTI (using the
IR conversion functions).

vex/priv/host-generic/reg_alloc2.c:684

      /* This reflects LibVEX's hard-wired knowledge of the baseBlock
         layout: the guest state, then an equal sized area following
         it for shadow state, and then the spill area. */
      vreg_lrs[j].spill_offset = toShort(guest_sizeB * 2 + k * 8);

ThreadArchState is within ThreadState (defined in coregrind/core.h)

./priv/host-generic/reg_alloc2.c:      // PG - modified offset from 2 to 6 (look in core_arch.h)
./priv/host-x86/isel.c:      // PG - Add handling for 4-byte PUTI's for tags



Ok, we fixed three problems today:
1.) Floating point stack problem (as evident in FloatTest)

The problem was that PUTI (Indexed PUT) is only used to write to the
floating-point stack, but Vex currently only allows 8-byte and 1-byte
writes for PUTI, 8-byte for doubles and 1-byte for the floating-point
'tags' (not the same as our tags).  We need to make an indexed 4-byte
write, so we simply relaxed a few assertions an added a case in the
x86->IR translator to handle 4-byte PUTI's.

Changes:

./priv/host-x86/isel.c:

Line 588:
   // PG - Added support for 4-byte writes of DynComp tags
   if (nElems != 8 || (elemSz != 1 && elemSz != 4 && elemSz != 8))
      vpanic("genGuestArrayOffset(x86 host)");

Line 608:
   // PG - Added support for 4-byte writes of DynComp tags
   vassert(elemSz == 1 || elemSz == 4 || elemSz == 8);
   // PG - Added support for 4-byte writes of DynComp tags
   return
      X86AMode_IRRS( descr->base, hregX86_EBP(), tmp,
                     elemSz==8 ? 3 :
                                 elemSz==4 ? 2 : 0);
}

Line 3313:
      // PG - Add handling for 4-byte PUTI's for tags
      if (ty == Ity_I32) {
         X86RI* ri = iselIntExpr_RI(env, stmt->Ist.PutI.data);
         addInstr(env, X86Instr_Alu32M(Xalu_MOV,ri,am));
         return;
      }


2.) Tags and V-bits clobbering each other because they both refer to
the same place in the shadow guest state

This change was a bit more involved.  The fundamental problem is that
Vex and Valgrind assume that tools will only need one fixed-sized
shadow guest state (for holding metadata about register,
floating-point stack, etc...).  We believe that this design decision
was made in order to make Memcheck work because Memcheck requires only
one shadow guest state for the V-bits.  However, we want to maintain
our own shadow guest state, which requires 4 bytes for EVERY field
of VexGuestX86State (we're just focusing on x86 for now).

The reason why we were getting all of those weird Memcheck errors when
running with DynComp was because both Memcheck and DynComp were
sharing the SAME shadow guest state (vex_shadow field in
ThreadArchState) and thus DynComp tags were being mis-interpreted as
V-bits.

Here is the hack that we used to resolve this problem:

In valgrind/coregrind/x86/core_arch.h, it's hard-coded into
ThreadArchState that there is one vex_shadow, so we just created an
extra shadow (called vex_extra_shadow) which is 4 times as big as the
original one.

valgrind/coregrind/x86/core_arch.h:

typedef
   struct {
      /* --- BEGIN vex-mandated guest state --- */

      /* Saved machine context. */
      VexGuestX86State vex;

      /* Saved shadow context. */
      VexGuestX86State vex_shadow;

      /* PG - Extra shadow guest state for DynComp */
      VexGuestX86State vex_extra_shadow[4];

      /* Spill area. */
      UChar vex_spill[LibVEX_N_SPILL_BYTES];

      /* --- END vex-mandated guest state --- */
   }
   ThreadArchState;


We need it to be 4X larger because we need a 4-byte tag for EVERY
field of VexGuestX86State, and the smallest entry is a 1-byte Char.
Now we need to multiply all offsets into vex_extra_shadow by 4 and all
should be well.  To properly handle GET, GETI, PUT, and PUTI calls for
DynComp, we must use the base value of TWICE total_sizeB (size of
VexGuestX86State) in order to get to the beginning of vex_extra_shadow
and then multiply all offsets by 4 because vex_extra_shadow is 4X the
size of a VexGuestX86State structure.

Modified functions in mc_translate.c:
do_shadow_PUT_DC, do_shadow_PUTI_DC, do_shadow_GET_DC, do_shadow_GETI_DC

e.g.
   stmt( dce->bb, IRStmt_Put( (4 * offset) + (2 * dce->layout->total_sizeB), vatom ) );

Now we also need to relax an assertion in ...

valgrind/coregrind/vg_scheduler.c:485
   // PG - changed from 2 to 6 to account for vex_extra_shadow in ThreadArchState
   vg_assert(a_vex + 6 * sz_vex == a_spill);

and finally modify the offset of the spill area in Vex:

vex/priv/host-generic/reg_alloc2.c:685

   // PG - changed from 2 to 6 to account for vex_extra_shadow in ThreadArchState
      vreg_lrs[j].spill_offset = toShort(guest_sizeB * 6 + k * 8);


3.) Multiplexor problem in IntTest This was dumb.  I need to simply
multiplex the values of the V-bits and pass them along within
expr2tags_Mux0X_DC.  I didn't do anything to handle this case before
so the IR was invalid.


TypesTest still fails!!! ARGGGGGG.

returnULongProduct(10000000, 0) = 1187331820519724672
GETI(880:8xI32)[t65,0]
vex: the `impossible' happened:
   iselIntExpr_R: cannot reduce tree
vex storage:  P 436,  T total 66334080 (1949455),  T curr 183020 (5359)

Look into this sometime.  It has to do with some double floating point
thing, since if we comment this out, it works:

/*     printf("returnDoubleSum(%f, %f) = %f\n", */
/* 	   (float)((a+b)/7), */
/* 	   (double)((2/b)*a), */
/* 	   returnDoubleSum((float)((a+b)/7), (double)((2/b)*a))); */


----------
2005-04-26
----------

This tiny program replicates the problem above.

double returnDoubleSum(double a, double b)
{
  return 0;
}

int main() {
  returnDoubleSum(1, 2);
  return 0;
}



GETI(880:8xI32)[t7,0]
vex: the `impossible' happened:
   iselIntExpr_R: cannot reduce tree

parsnip:/scratch/pgbovine-do-not-delete-me/xtide/bin/xtide
shares the SAME failure


Hmm, if I comment-out handling for:

      case Iex_Mux0X:
         return IRExpr_Const(IRConst_U32(0));
         //         return expr2tags_Mux0X_DC( dce, e->Iex.Mux0X.cond, e->Iex.Mux0X.expr0,
         //                                    e->Iex.Mux0X.exprX);

... everything seems to work properly

But it may have something to do with CCall.  Look in isel.c for
'irreducible':

For CCalls:
      /* be very restrictive for now.  Only 32/64-bit ints allowed
         for args, and 32 bits for return type. */
      if (e->Iex.CCall.retty != Ity_I32)
         goto irreducible;

but the problem may not be in CCall at all.  If nothing matches in the
switch statement, this line still executes:

   /* We get here if no pattern matched. */
  irreducible:
   ppIRExpr(e);
   vpanic("iselIntExpr_R: cannot reduce tree");


GETI is most likely the culprit!
GETI(880:8xI32)[t7,0]

It's just another instance of the 'not-supporting 4-byte get/put' for
x87 floating-point stack in isel.c:

Add this line to isel.c and all should be well :)

      // PG - Add support for 32-bit GETI's for DynComp tags
      if (ty == Ity_I32) {
         addInstr(env, X86Instr_Alu32R(
                          Xalu_MOV,
                          X86RMI_Mem(am),
                          dst));
         return dst;
      }


Clean calls are intuitively the correct thing for tag MERGES (and
they're faster), although they may be optimized away in some special
cases.

Do a clean call for most merges and do a few dirty calls to 'anchor'
the computation so that the optimizer doesn't optimize stuff away.

For the MUX and conditional exit (i.e., if (expr1) goto
literal-value), add a no-op dirty call which takes 1 tag in and does
nothing so that the optimizer doesn't destroy it.

e.g.

Mux: 'Mux0X(exprC, expr0, exprX)'

Conceptually, the return value of processing the tags for this
expression is just a parallel Mux with the SAME condition but the tags
of the expressions:

Mux0X(exprC, tag(expr0), tag(exprX))

Although exprC is an IRAtom (temp or constant), a super-complicated
expression might have resulted in that temp.  What if exprC is TEMP
which is the result of evaluating a complicated expression with lots
of interesting interactions?  The IR optimizer might blow away the
tree branch containing all of the interesting tag merges if the
resulting temp is not used anywhere (since all the tag merges are
clean calls).  Thus, we need to anchor it by adding a temporary t with
a dirty call (which cannot be optimized away) such that:

t = dirty_NOP(tag(exprC))

We don't really use t for anything, but we need it as an ANCHOR to
prevent the optimizer from blowing away tag merge interactions arising
from exprC.

Conditional exits: 'if (expr1) goto literal-value'

Ditto for expr1 here.


----------
2005-04-27
----------

Questions for Stephen during our weekly meeting (Look at TODO's):

1. Do we have the annotations for the dirty helpers correct for MERGE_TAG
and CREATE_TAG (as stated in setHelperAnns_DC()).  I guess we don't
explicitly access guest state in either of these.

They can probably go away because SP and IP are only accessed during
error reporting (backtraces)

2. Are the AND, OR, etc... binary ops. bitwise by default?  If so, we
should count them as interactions?  But what about logical AND/OR?  We
don't want to count (apples || oranges) as interactions, but if it
gets translated into the same IR instructions as (apples | oranges),
then we can't tell the difference, right?  We need to err one way or
another, and I think that logical AND/OR in C are more common than
bitwise ones.

BITWISE! - Logical AND's and OR's are compiled as branches.

3. Make sure my handling of unary ops (no handling at all) is correct.

Good.

4. How do pointer values get created using &-operator and malloc?  I
guess I'll experiment and find out.

It will either look like a literal or arithmetic on ESP/EBP.  Right
now we don't create new tags on malloc and friends.  It's not clear
that tags for pointers are that important.

5. Optimization - how do we avoid all of these CREATE_TAGS when most
of them are useless?

6. Perhaps most important.  Ok, I got how to do function entrances,
but how do I do function exits without the address available in the
Ist_Exit statement?  Maybe I need to cue off of the PREVIOUS IMark
statement, which seems like a pain.  Yeah, this seems to work, but is
there an easier way?

Check out libvex_ir.h:

Look at the Ret jump kind for function exits?

typedef
   enum {
      Ijk_Boring=0x14000, /* not interesting; just goto next */
      Ijk_Call,           /* guest is doing a call */
      Ijk_Ret,            /* guest is doing a return */
      Ijk_ClientReq,      /* do guest client req before continuing */
      Ijk_Syscall,        /* do guest syscall before continuing */
      Ijk_Yield,          /* client is yielding to thread scheduler */
      Ijk_EmWarn,         /* report emulation warning before continuing */
      Ijk_NoDecode,       /* next instruction cannot be decoded */
      Ijk_MapFail,        /* Vex-provided address translation failed */
      Ijk_TInval          /* Invalidate translations before continuing. */
   }
   IRJumpKind;

Also look into Ist_IMark for markers for function entrance/exit!


----------
2005-04-28
----------

In tool.h, it looks like you can register Valgrind tools to pick up on
specific events, such as ESP changing.  Perhaps this is more elegant
than hacking mac_shared.h directly to put in our own check_ESP(), but
maybe it would be slower.

Perhaps think about making a Fjalar 1.0 which abstracts out the common
parts of Kvasir and DynComp.  During our crazy variable traversal,
take a function pointer parameter so that we can polymorphically do
dtrace or DynComp output.  Create nice abstractions.

How do we get R_ESP???  In CHECK_ESP(), you can get it from the
argument.  But how do you get it into the argument?  We need some IR
statement which grabs the guest state's ESP wheneve it's executed.

When you annotate a dirty helper to say that it uses the ESP, then it
ensures that ESP is written to the guest state.

Ha! In tool.h:

/* Get the TID of the thread which currently has the CPU. */
extern ThreadId VG_(get_running_tid) ( void );

/* Searches through all thread's stacks to see if any match.  Returns
   VG_INVALID_THREADID if none match. */
extern ThreadId VG_(first_matching_thread_stack)
                        ( Bool (*p) ( Addr stack_min, Addr stack_max, void* d ),
                          void* d );

/* Get parts of the client's state. */
extern Addr VG_(get_SP) ( ThreadId tid );
extern Addr VG_(get_IP) ( ThreadId tid );



Hmmm, check out this thing about shadow memory from tool.h:

/* Does the tool need shadow memory allocated (if you set this, you must also statically initialize
   float TL_(shadow_ratio) = n./m;
   to define how many shadow bits you need per client address space bit.
*/
extern void VG_(needs_shadow_memory)( void );
extern float TL_(shadow_ratio);


Hmmm, wait I don't think we need to hack around using the actual x86
floating-point stack anymore.  We actually have a shadow
floating-point stack now :)

Hmmm, the problem now seems to be that I can't properly get
floating-point return values off of the top of the guest_FPREG.
Perhaps my dirty helper annotations in handle_possible_exit_DC()
aren't correct or something, but it ain't working.

An alternative is that we could add an explicit GETI as an IR
instruction (created in handle_possible_exit_DC()) to get the value of
the FPU stack top during execution instead of grabbing it ourselves.


Ok, the biggest problem right now is that floating point stuff doesn't
work correctly :(


Also, it doesn't properly handle command-line options :(

While we're busy porting/refactoring, get rid of Demsky's
GenericHashtable and use Valgrind's own hash table.  Also, try to
abstract out Fjalar stuff using function pointers/stuff?


----------
2005-04-29
----------

Ok, command-line options and floating-point have been fixed quite
easily by fixing my stupid typos.  Now the V-bits on the
floating-point stack still don't seem to be working correctly.  I will
investigate right now.

extern void *VG_(shadow_alloc)(UInt size); <--- Hmmm, should I use
this to allocate all of my junk?


Ok, my problem now is to try to get A and V bits working for EAX, EDX,
and FPU because I don't want to have special 'overrideIsInitialized'
handling for them 'cause that's lame.  Copying A/V-bits over to
virtualStack seems to work, but not for registers in the guest state.
Gotta investigate further ...

The question now becomes ... does Memcheck do A/V-bit tracking on
Kvasir's own C code?  Or does it only do tracking on client code?
Like what if I pass pointers to local variables (in Kvasir functions)
around?  Do these get associated A and V-bits?  I'm starting to doubt
it :(

Ok, it seems like the EAX/EDX shadow bits are working great, but the
FPU shadow bits are way the hell off.  I've gotta investigate that.
* Ok, done.  It was a stupid '&' typo in coregrind/vg_main.c

----------
2005-05-01
----------

Wow, really good news!  It seems that when I run the Kvasir tests with
Kvasir_DC (Kvasir + DynComp), I get a lot better results for
floating-point values.  Whereas before, some of them would print out
as 'uninit', now they print out as their real values!

Hmmm ... we still don't seem to be getting the validity of array
contents correctly for stuff in the bc regression test, but I'll
ignore that for now.


----------
2005-05-03
----------

Ok, it's time to start implementing the variable comparability stuff.

For the purposes of comparability, we need to keep 'variables' for all
the Daikon-derived crap, but we don't have DaikonVariable entries for
all of them.  This means that as we traverse through stuff during the
.decls run, we need to build up a mapping of variables (referenced
purely by *strings* since DaikonVariable entries are not unique up to
pointer dereference levels) to uf_objects.


Ok, I am still struggling to understand Stephen's algorithm.  I know
that outputDtraceValue() needs to be augmented to take in some more
stuff, but I'll think more about it tomorrow.


----------
2005-05-04
----------

Umm, when we observe variable values in dtrace-output.c, what if the
variable in unallocated or uninitialized?  I assume that we just skip
it and leave its tag as 0 for this particular instance of the program
point.

Look into doing less merges in dtrace-output.c because we shouldn't
merge when we don't need to.  For the example of outputting 4-byte
ints, those tags should already be merged when reading them out of
registers and into memory, right?

Hmmm, the return values have a tag of 0, which is strange.  Ahhh,
perhaps they are not shadows properly with tags - ok, fixed now!


Ok, question about hashing.  Does it matter what number we mod ('%')
the size by?  I mean, the size of the hash table does change, right?
So which number is good for the hash function?  Or does it not matter
because GenericHashtable will mod it for us?  Oh, haha, it does mod it
for us :) So don't worry about modding ourselves!


----------
2005-05-05
----------

Notes from meeting with Stephen:


Using tags as Daikon comparability numbers
------------------------------------------

Can use use the tags as Daikon comparability numbers in the .dtrace
file?  I guess so.  If we're afraid of the tags being too big, just
subtract everything by the smallest tag ever observed :)  Yes, but BE
CAREFUL about large numbers.  The tags are UInts but Daikon represents
comparability numbers as signed ints (Stephen thinks so).

If we're afraid that there are too many tags in existence, we could
really just subtract all tags at EACH program point by the smallest
one AT THAT program point.  This will mean that there are
comparability number duplications across program points, but Daikon
doesn't really care at all.


Future research question
------------------------

Once we get a good working prototype and are able to evaluate its
results, consider refining the algorithm to provide more precise
information.  Currently, we are restricted by the fact that the
variable comparability sets are always supersets of the value
comparability sets.  This makes the implementation much easier and
cleaner, but may result in coarser-grained info. (which may or may not
be a bad thing in practice).  However, assuming that we don't make the
assumption that var. sets and supersets of value sets, then how could
we implement this efficiently without keeping around too much info. and
doing post-processing (which is unreasonable).  We need an on-the-fly
algorithm to create finer partitions.  However, it doesn't matter for
now because we just want a prototype which works.


The current algorithm explained
-------------------------------

SMcC's current algorithm for propagating value comparability to
variable comparability sets at each program point (annotated by
pgbovine)

Each program point has its own copy of the following data structures:

var_uf_map:
Key: tag which is a leader of some entry in val_uf
Value: uf_object

Define a function (implemented as a non-null hashtable get)
var_uf_map.exists(val_uf leader entry) returns true if entry from
val_uf exists in var_uf_map.

var_uf_map is the variable analogue to val_uf, which is the union-find
for all values ever created in a program.

var_tags: A fixed-sized array (indexed by the serial # of Daikon
variables at that program point) which contains tags which are the
leaders of the comparability sets of their value's tags at that
program point.

new_tags: A fixed-sized array (also indexed by # of Daikon variables)
of the tags extracted by a certain Daikon variable's value at this
program point.  This structure is updated EVERY TIME the program
executes a program point by querying val_uf with the address of the
variable's value being observed and getting back the tag.

The size of var_tags and new_tags can be initialized during the .decls
run because we can count up how many Daikon variables exist at that
program point.  The number of Daikon variables as well as their order
is maintained during all program point executions in the .dtrace run
because the same traversal function is executing for both .decls and
.dtrace (and more importantly, because Daikon expects the front-end
output to maintain these variables in the same order).


Pseudo-code of the conversion from value to variable comparability
which occurs at every program point:

for each variable indexed by v {
  // Update from any val_uf merges that have occurred for variables on
  // previous executions of this program point.

  // Make sure that the degenerate behavior of this line is that it
  // returns 0 so we don't do anything when there's no previous info.
  // to update
  tag leader = val_uf.find(var_tags[v]);
  if (leader != var_tags[v]) {
    var_tags[v] = var_uf_map.union(leader, var_tags[v]);
  }


  // Make sure that an entry is created in var_uf_map for the tag
  // associated with the new value that we observe from the
  // memory-level layer
  tag new_leader = val_uf.find(new_tags[v]);
  if (!var_uf_map.exists(new_leader)) {
    var_uf_map.insert(new_leader, make_set(new uf_object));
  }

  // Merge the sets of all values that were observed before for this
  // variable at this program point with the new value that we just
  // observed
  var_tags[v] = var_uf_map.union(var_tags[v], new_leader);
}

Notice that val_uf is NEVER modified, only observed.  This is crucial
in keeping the separation in layers between the variable (language)
and value (memory) levels.  The concept is that tags may be merged at
the variable level without being merged at the value level.
