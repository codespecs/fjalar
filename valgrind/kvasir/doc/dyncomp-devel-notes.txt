DynComp Dynamic Comparability Analysis development notes
by Philip Guo

----------
2005-04-12
----------

When I run dyncomp on 'date' and Memcheck on 'date', dyncomp gives a
lot more uninitialized value warnings.  Memcheck seems to generate
these similar warnings but suppresses them.

dyncomp:
...
==24247== Conditional jump or move depends on uninitialised value(s)
==24247==    at 0x1B8ED585: _dl_relocate_object (in /lib/ld-2.3.2.so)
==24247==    by 0x1B8E6098: (within /lib/ld-2.3.2.so)
==24247==    by 0x1B8F30FC: (within /lib/ld-2.3.2.so)
==24247==    by 0x1B8E4F3A: (within /lib/ld-2.3.2.so)
==24247==    by 0x1B8E4C26: (within /lib/ld-2.3.2.so)
==24247==
==24247== Conditional jump or move depends on uninitialised value(s)
==24247==    at 0x1B8ED3DA: _dl_relocate_object (in /lib/ld-2.3.2.so)
==24247==    by 0x1B8E60DF: (within /lib/ld-2.3.2.so)
==24247==    by 0x1B8F30FC: (within /lib/ld-2.3.2.so)
==24247==    by 0x1B8E4F3A: (within /lib/ld-2.3.2.so)
==24247==    by 0x1B8E4C26: (within /lib/ld-2.3.2.so)
==24247==
==24247== Conditional jump or move depends on uninitialised value(s)
==24247==    at 0x1B8ED3E8: _dl_relocate_object (in /lib/ld-2.3.2.so)
==24247==    by 0x1B8E60DF: (within /lib/ld-2.3.2.so)
==24247==    by 0x1B8F30FC: (within /lib/ld-2.3.2.so)
==24247==    by 0x1B8E4F3A: (within /lib/ld-2.3.2.so)
==24247==    by 0x1B8E4C26: (within /lib/ld-2.3.2.so)
==24247==
==24247== Conditional jump or move depends on uninitialised value(s)
==24247==    at 0x1B8ED585: _dl_relocate_object (in /lib/ld-2.3.2.so)
==24247==    by 0x1B8E60DF: (within /lib/ld-2.3.2.so)
==24247==    by 0x1B8F30FC: (within /lib/ld-2.3.2.so)
==24247==    by 0x1B8E4F3A: (within /lib/ld-2.3.2.so)
==24247==    by 0x1B8E4C26: (within /lib/ld-2.3.2.so)
Tue Apr 12 16:25:24 EDT 2005
==24247==
==24247== ERROR SUMMARY: 20 errors from 8 contexts (suppressed: 0 from 0)
==24247== malloc/free: in use at exit: 6186 bytes in 42 blocks.
==24247== malloc/free: 47 allocs, 5 frees, 8051 bytes allocated.
==24247== For counts of detected errors, rerun with: -v
==24247== searching for pointers to 42 not-freed blocks.
==24247== checked 415748 bytes.
==24247==
==24247== LEAK SUMMARY:
==24247==    definitely lost: 0 bytes in 0 blocks.
==24247==      possibly lost: 0 bytes in 0 blocks.
==24247==    still reachable: 6186 bytes in 42 blocks.
==24247==         suppressed: 0 bytes in 0 blocks.
==24247== Reachable blocks (those to which a pointer was found) are not shown.
==24247== To see them, rerun with: --show-reachable=yes


Memcheck:

Tue Apr 12 16:25:51 EDT 2005
==24386==
==24386== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 20 from 1)
==24386== malloc/free: in use at exit: 6186 bytes in 42 blocks.
==24386== malloc/free: 47 allocs, 5 frees, 8051 bytes allocated.
==24386== For counts of detected errors, rerun with: -v
==24386== searching for pointers to 42 not-freed blocks.
==24386== checked 415748 bytes.
==24386==
==24386== LEAK SUMMARY:
==24386==    definitely lost: 0 bytes in 0 blocks.
==24386==      possibly lost: 0 bytes in 0 blocks.
==24386==    still reachable: 6186 bytes in 42 blocks.
==24386==         suppressed: 0 bytes in 0 blocks.
==24386== Reachable blocks (those to which a pointer was found) are not shown.
==24386== To see them, rerun with: --show-reachable=yes


Notice that Memcheck suppressed 20 warnings but dyncomp didn't.  This
is weird because I've copied dyncomp over from Memcheck and only
changed its name.  Oh well ... maybe the Memcheck developers
suppressed certain errors which only match up with something that's
dependent on the Memcheck name.  This is probably not a big deal since
we don't care about leak checking anyways.


----------
2005-04-13
----------

/* Allocate a new shadow for the given original tmp.  This means any
   previous shadow is abandoned.  This is needed because it is
   necessary to give a new value to a shadow once it has been tested
   for undefinedness, but unfortunately IR's SSA property disallows
   this.  Instead we must abandon the old shadow, allocate a new one
   and use that instead. */
static void newShadowTmp ( MCEnv* mce, IRTemp orig )

In (mc_translate.c):
Check this out.  One of the first problems I need to solve is how
Memcheck automatically sets a byte to defined after it has been tested
for undefinedness in order to avoid propagating errors.  We need to
disable this functionality.


/* Check the supplied **original** atom for undefinedness, and emit a
   complaint if so.  Once that happens, mark it as defined.  This is
   possible because the atom is either a tmp or literal.  If it's a
   tmp, it will be shadowed by a tmp, and so we can set the shadow to
   be defined.  In fact as mentioned above, we will have to allocate a
   new tmp to carry the new 'defined' shadow value, and update the
   original->tmp mapping accordingly; we cannot simply assign a new
   value to an existing shadow tmp as this breaks SSAness -- resulting
   in the post-instrumentation sanity checker spluttering in disapproval.
*/
static void complainIfUndefined ( MCEnv* mce, IRAtom* atom )

From the Memcheck user's manual (mc_main.html):
If a check should detect undefinedness, an error message is
issued. The resulting value is subsequently regarded as
well-defined. To do otherwise would give long chains of error
messages. In effect, we say that undefined values are non-infectious.


I think that commenting out all the complainIfUndefined() calls in
mc_translate.c should do the trick.



/*------------------------------------------------------------*/
/*--- Generate shadow values from all kinds of IRExprs.    ---*/
/*------------------------------------------------------------*/

static
IRAtom* expr2vbits_Binop ( MCEnv* mce,
                           IROp op,
                           IRAtom* atom1, IRAtom* atom2 )

This huge function seems to generate the shadow values for all sorts
of expressions.  Perhaps this is what I should hack on.

The ENSURE_MAPPABLE(addr,caller) macro in mac_shared.h seems to be the
only thing that calls alloc_secondary_map() to allocate a new
secondary map if the current one for the address addr is distinguished
(uninitialized and/or unallocated).


----------
2005-04-14
----------

The best way is to eliminate the tags from the memcheck structures
and just have our own (because their optimization messes us up)

When do we have instructions which create a new value in memory?

Tags are associated with valid V-bits - tags are needed for a byte
when at least 1 V-bit in your byte is valid.  V-bits get set when you
overwrite stuff.  We want to destroy old tag and move a new one in
when none of the original data can be recovered

Globals:
Every byte needs a new unique tag upon program instantiation
There is probably some special case for this

set_address_range_perms is probably what sets all the global area to A
and V; need to do similar things with tags

Stack:
Local variables - upon function entrance, moves ESP down a whole chunk
at a time

int x = 10;
x = 6;
int y = 15;

In x86, you can either have '10' write to a register then write the
register into memory, or have an instruction that directly writes '10'
into memory.  But the important thing to note is that the creation of
the literal '10' is what creates the tag and moves it into either
register or memory.  We need tags associated with registers as well as
memory.

IR is maybe some kind of expression tree which implicitly assigns
names to stuff -

(Maybe) Memcheck must somehow make a new parallel expression tree for
A/V-bits

mc_translate.c

temps
newShadowTmp()?

shadowing - given the tree for the actual expressions, give me the
corresponding one for the V-bits (A-bits don't have to do with
operations, only on memory allocation)

PUT/GET :: STORE/LOAD


expr2vbits_Binop() - the tree-walk which builds up the parallel trees

We start with x86 -> IR tree and then walk it to build up a v-bit tree

Input tree is probably fairly linear but we want a tree representation

IR has two levels - statements and atoms (expressions)

         case Ist_Tmp:
            assign( bb, findShadowTmp(&mce, st->Ist.Tmp.tmp),
                        expr2vbits( &mce, st->Ist.Tmp.data) );
            break;

This seems to be the meaty call

We need some instructions to write to tags just like how they write
instructions to write A and V bits


/* Generate a shadow store.  addr is always the original address atom.
   You can pass in either originals or V-bits for the data atom, but
   obviously not both.  */

static
void do_shadow_STle ( MCEnv* mce,
                      IRAtom* addr, UInt bias,
                      IRAtom* data, IRAtom* vdata )

We need vars to keep track of tags - we need store and load tag
operations in mc_translate.c

We need helpers for store tag, load tag, and merge-two-tags

When we do 32-bit operations, we should just unify them into one tag

LOAD is an expression whereas STORE is a statement

STORE has to be a statement because it has side effects (you can swap
a LOAD/STORE or two STOREs)

Input from the user is conceptually a place where you get new data

If you do ESP + 1, you need to get a new tag because of &-operators

We seem to need a parallel tmpMap

We need to create parallel helper functions to deal with tags:
VGA_REGPARM(1)
UInt MC_(helperc_LOADV1) ( Addr a )



static
void mc_new_mem_startup( Addr a, SizeT len, Bool rr, Bool ww, Bool xx )

static
void mc_new_mem_heap ( Addr a, SizeT len, Bool is_inited )

static
void mc_new_mem_mmap ( Addr a, SizeT len, Bool rr, Bool ww, Bool xx )


We may be able to mc_new_mem_heap to create tags and stuff
and zero stuff out when stack pointer moves


We have two problems to solve:

The easy one: Statically-initialized things - we can simply plug stuff
into mc_main.c.

The hard one: Dynamic events - we need to actually instrument the IR
and do funky stuff.


Do we need any special handling of malloc() and friends?


What do we do with init_new_mem_stack, init_die_mem_stack and friends?


----------
2005-04-17
----------

I turned on 'verboze' in mc_translate.c:TL_(instrument) and diff'ed
two versions of SuperSimpleTest, one with an extra 'int z = x + y;'
statement and here was the main difference:

------ IMark(0x8048375, 3) ------


PUT(56) = 0x8048375:I32


t33 = Add32(t23,0xFFFFFFFC:I32)

   t75 = Or32(t45,0x0:I32)
   t76 = Sub32(0x0:I32,t75)
   t77 = Or32(t75,t76)
   t78 = t77

t15 = LDle:I32(t33)

   t79 = DIRTY 1:I1 RdFX-gst(16,4) RdFX-gst(56,4) ::: MC_(helperc_LOADV4)[rp=1]{0xB125FDF7}(t33)
   t80 = t79

t14 = Add32(t32,t15)

   t81 = Or32(t74,t80)
   t82 = Sub32(0x0:I32,t81)
   t83 = Or32(t81,t82)
   t84 = t83

PUT(32) = 0x3:I32


PUT(36) = t32

   PUT(348) = t74

PUT(40) = t15

   PUT(352) = t80

PUT(44) = 0x0:I32


------ IMark(0x8048378, 3) ------


PUT(56) = 0x8048378:I32


t35 = Add32(t23,0xFFFFFFF4:I32)

   t85 = Or32(t45,0x0:I32)
   t86 = Sub32(0x0:I32,t85)
   t87 = Or32(t85,t86)
   t88 = t87

STle(t35) = t14

   DIRTY 1:I1 RdFX-gst(16,4) RdFX-gst(56,4) ::: MC_(helperc_STOREV4)[rp=2]{0xB125FE46}(t35,t84)



Look in do_shadow_STle:

See the 'void* helper' local variable?  We need to somehow hijack this
one so that we can call our own nifty helper functions at certain
instructions.  From my observation, what Memcheck does is create new
IR trees which contain primitive operations (i.e. AND, OR) on the
V-bits, but there are no primitive operations for "merge tags"
et. al. so that we need to simply suck it up and call our own helper
functions. (Check out setHelperAnns(), unsafeIRDirty_0_N(),
unsafeIRDirty_1_N())

/vex/pub/libvex_ir.h contains some useful IR definitions

IRCallee seems to describe a helper function to call
mkIRCallee(), dopyIRCallee(), etc...

IRExpr_CCall is for pure (no side effects) helper functions whereas
IRStmt_Dirty is for non-pure ones

If you make a dirty call, you must specify EXACTLY which memory areas
you are going to affect, etc...

We definitely need to use tmps to make copies of tags as they flow
from place-to-place.  Otherwise, when there is an operation which
involves two registers (i.e. ADD R1 R2), we have no clue about the
tags of R1 and R2


Super ghetto solution - make a copy of all of the Memcheck
instrumentation code and DUPLICATE it for tags.  Then modify
TL_(instrument) to create BOTH tag and A/V-bit-manipulation
instructions for all inputted instructions


***
What do we do when we read multiple bytes from memory?  Do we merge
the tags associated with all of these bytes and just return one tag?
That seems like it may lose some precision but it's just much easier
to implement (at least for now).
***

helperc_STORE_TAG_4(0x52BFE3BC, 0) [nextTag=110593]
helperc_STORE_TAG_4(0x52BFE3B8, 0) [nextTag=110593]
helperc_STORE_TAG_4(0x52BFE3B4, 0) [nextTag=110593]
helperc_STORE_TAG_4(0x52BFE3B0, 0) [nextTag=110593]
helperc_STORE_TAG_4(0x52BFE3AC, 0) [nextTag=110593]
helperc_STORE_TAG_4(0x52BFE35C, 0) [nextTag=110593]
helperc_LOAD_TAG_4(0x52BFE35C) = 0 [nextTag=110593]
helperc_LOAD_TAG_4(0x52BFE35C) = 0 [nextTag=110593]
helperc_STORE_TAG_4(0x52BFE388, 0) [nextTag=110593]
helperc_LOAD_TAG_4(0x1B8FAC00) = 101377 [nextTag=110593]
helperc_STORE_TAG_4(0x1B8FA66C, 4294967295) [nextTag=110593]   <---- PROBLEM!!!
helperc_STORE_TAG_4(0x1B8FA674, 4294967295) [nextTag=110593]   <---- PROBLEM!!!
helperc_STORE_TAG_4(0x52BFE380, 0) [nextTag=110593]
helperc_LOAD_TAG_4(0x52BFE380) = 0 [nextTag=110593]
helperc_STORE_TAG_4(0x52BFE384, 0) [nextTag=110593]
helperc_LOAD_TAG_4(0x1B8FA674) = 4294967295 [nextTag=110593]   <---- PROBLEM!!!

Look at big-output.pid2528 to see the results of the loads and store
helper function calls: Ummm, there is this mystery garbage value
(4294967295, which is 0xffffffff) likely caused by a bogus store ...
which means that we are storing garbage, which ain't good.

Also other weird garbage values: 4294967280 (0xfffffff0)

I'm trying to get rid of these!!! (Really bad hack - check store
tag values to make sure that they are below 'nextTag', but this is a
bad way to patch up the problem.)

I probably need to clean up the rest of the DynComp code before going
back to this.  Perhaps the rest of the incompatibilities are causing
these bogus values to be stored.  It's still too early to get to the
bottom of this problem.


----------
2005-04-20
----------

Ok, got rid of the garbage values (by disabling handling of unary ops)
and started getting something to work with MERGE_TAGS, except that the
second tag parameter is ALWAYS 0.  That's no good :(

e.g.

helperc_STORE_TAG_4(0x52BFE354, 101913) [nextTag=1466035]
helperc_MERGE_TAGS_4(101913, 0) [nextTag=1466035]
helperc_STORE_TAG_4(0x52BFE350, 110758) [nextTag=1466035]
helperc_MERGE_TAGS_4(101913, 0) [nextTag=1466035]
helperc_STORE_TAG_4(0x52BFE34C, 0) [nextTag=1466035]
