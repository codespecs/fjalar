DynComp Dynamic Comparability Analysis development notes
by Philip Guo

----------
2005-04-12
----------

When I run dyncomp on 'date' and Memcheck on 'date', dyncomp gives a
lot more uninitialized value warnings.  Memcheck seems to generate
these similar warnings but suppresses them.

dyncomp:
...
==24247== Conditional jump or move depends on uninitialised value(s)
==24247==    at 0x1B8ED585: _dl_relocate_object (in /lib/ld-2.3.2.so)
==24247==    by 0x1B8E6098: (within /lib/ld-2.3.2.so)
==24247==    by 0x1B8F30FC: (within /lib/ld-2.3.2.so)
==24247==    by 0x1B8E4F3A: (within /lib/ld-2.3.2.so)
==24247==    by 0x1B8E4C26: (within /lib/ld-2.3.2.so)
==24247==
==24247== Conditional jump or move depends on uninitialised value(s)
==24247==    at 0x1B8ED3DA: _dl_relocate_object (in /lib/ld-2.3.2.so)
==24247==    by 0x1B8E60DF: (within /lib/ld-2.3.2.so)
==24247==    by 0x1B8F30FC: (within /lib/ld-2.3.2.so)
==24247==    by 0x1B8E4F3A: (within /lib/ld-2.3.2.so)
==24247==    by 0x1B8E4C26: (within /lib/ld-2.3.2.so)
==24247==
==24247== Conditional jump or move depends on uninitialised value(s)
==24247==    at 0x1B8ED3E8: _dl_relocate_object (in /lib/ld-2.3.2.so)
==24247==    by 0x1B8E60DF: (within /lib/ld-2.3.2.so)
==24247==    by 0x1B8F30FC: (within /lib/ld-2.3.2.so)
==24247==    by 0x1B8E4F3A: (within /lib/ld-2.3.2.so)
==24247==    by 0x1B8E4C26: (within /lib/ld-2.3.2.so)
==24247==
==24247== Conditional jump or move depends on uninitialised value(s)
==24247==    at 0x1B8ED585: _dl_relocate_object (in /lib/ld-2.3.2.so)
==24247==    by 0x1B8E60DF: (within /lib/ld-2.3.2.so)
==24247==    by 0x1B8F30FC: (within /lib/ld-2.3.2.so)
==24247==    by 0x1B8E4F3A: (within /lib/ld-2.3.2.so)
==24247==    by 0x1B8E4C26: (within /lib/ld-2.3.2.so)
Tue Apr 12 16:25:24 EDT 2005
==24247==
==24247== ERROR SUMMARY: 20 errors from 8 contexts (suppressed: 0 from 0)
==24247== malloc/free: in use at exit: 6186 bytes in 42 blocks.
==24247== malloc/free: 47 allocs, 5 frees, 8051 bytes allocated.
==24247== For counts of detected errors, rerun with: -v
==24247== searching for pointers to 42 not-freed blocks.
==24247== checked 415748 bytes.
==24247==
==24247== LEAK SUMMARY:
==24247==    definitely lost: 0 bytes in 0 blocks.
==24247==      possibly lost: 0 bytes in 0 blocks.
==24247==    still reachable: 6186 bytes in 42 blocks.
==24247==         suppressed: 0 bytes in 0 blocks.
==24247== Reachable blocks (those to which a pointer was found) are not shown.
==24247== To see them, rerun with: --show-reachable=yes


Memcheck:

Tue Apr 12 16:25:51 EDT 2005
==24386==
==24386== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 20 from 1)
==24386== malloc/free: in use at exit: 6186 bytes in 42 blocks.
==24386== malloc/free: 47 allocs, 5 frees, 8051 bytes allocated.
==24386== For counts of detected errors, rerun with: -v
==24386== searching for pointers to 42 not-freed blocks.
==24386== checked 415748 bytes.
==24386==
==24386== LEAK SUMMARY:
==24386==    definitely lost: 0 bytes in 0 blocks.
==24386==      possibly lost: 0 bytes in 0 blocks.
==24386==    still reachable: 6186 bytes in 42 blocks.
==24386==         suppressed: 0 bytes in 0 blocks.
==24386== Reachable blocks (those to which a pointer was found) are not shown.
==24386== To see them, rerun with: --show-reachable=yes


Notice that Memcheck suppressed 20 warnings but dyncomp didn't.  This
is weird because I've copied dyncomp over from Memcheck and only
changed its name.  Oh well ... maybe the Memcheck developers
suppressed certain errors which only match up with something that's
dependent on the Memcheck name.  This is probably not a big deal since
we don't care about leak checking anyways.


----------
2005-04-13
----------

/* Allocate a new shadow for the given original tmp.  This means any
   previous shadow is abandoned.  This is needed because it is
   necessary to give a new value to a shadow once it has been tested
   for undefinedness, but unfortunately IR's SSA property disallows
   this.  Instead we must abandon the old shadow, allocate a new one
   and use that instead. */
static void newShadowTmp ( MCEnv* mce, IRTemp orig )

In (mc_translate.c):
Check this out.  One of the first problems I need to solve is how
Memcheck automatically sets a byte to defined after it has been tested
for undefinedness in order to avoid propagating errors.  We need to
disable this functionality.


/* Check the supplied **original** atom for undefinedness, and emit a
   complaint if so.  Once that happens, mark it as defined.  This is
   possible because the atom is either a tmp or literal.  If it's a
   tmp, it will be shadowed by a tmp, and so we can set the shadow to
   be defined.  In fact as mentioned above, we will have to allocate a
   new tmp to carry the new 'defined' shadow value, and update the
   original->tmp mapping accordingly; we cannot simply assign a new
   value to an existing shadow tmp as this breaks SSAness -- resulting
   in the post-instrumentation sanity checker spluttering in disapproval.
*/
static void complainIfUndefined ( MCEnv* mce, IRAtom* atom )

From the Memcheck user's manual (mc_main.html):
If a check should detect undefinedness, an error message is
issued. The resulting value is subsequently regarded as
well-defined. To do otherwise would give long chains of error
messages. In effect, we say that undefined values are non-infectious.


I think that commenting out all the complainIfUndefined() calls in
mc_translate.c should do the trick.



/*------------------------------------------------------------*/
/*--- Generate shadow values from all kinds of IRExprs.    ---*/
/*------------------------------------------------------------*/

static
IRAtom* expr2vbits_Binop ( MCEnv* mce,
                           IROp op,
                           IRAtom* atom1, IRAtom* atom2 )

This huge function seems to generate the shadow values for all sorts
of expressions.  Perhaps this is what I should hack on.

The ENSURE_MAPPABLE(addr,caller) macro in mac_shared.h seems to be the
only thing that calls alloc_secondary_map() to allocate a new
secondary map if the current one for the address addr is distinguished
(uninitialized and/or unallocated).


----------
2005-04-14
----------

The best way is to eliminate the tags from the memcheck structures
and just have our own (because their optimization messes us up)

When do we have instructions which create a new value in memory?

Tags are associated with valid V-bits - tags are needed for a byte
when at least 1 V-bit in your byte is valid.  V-bits get set when you
overwrite stuff.  We want to destroy old tag and move a new one in
when none of the original data can be recovered

Globals:
Every byte needs a new unique tag upon program instantiation
There is probably some special case for this

set_address_range_perms is probably what sets all the global area to A
and V; need to do similar things with tags

Stack:
Local variables - upon function entrance, moves ESP down a whole chunk
at a time

int x = 10;
x = 6;
int y = 15;

In x86, you can either have '10' write to a register then write the
register into memory, or have an instruction that directly writes '10'
into memory.  But the important thing to note is that the creation of
the literal '10' is what creates the tag and moves it into either
register or memory.  We need tags associated with registers as well as
memory.

IR is maybe some kind of expression tree which implicitly assigns
names to stuff -

(Maybe) Memcheck must somehow make a new parallel expression tree for
A/V-bits

mc_translate.c

temps
newShadowTmp()?

shadowing - given the tree for the actual expressions, give me the
corresponding one for the V-bits (A-bits don't have to do with
operations, only on memory allocation)

PUT/GET :: STORE/LOAD


expr2vbits_Binop() - the tree-walk which builds up the parallel trees

We start with x86 -> IR tree and then walk it to build up a v-bit tree

Input tree is probably fairly linear but we want a tree representation

IR has two levels - statements and atoms (expressions)

         case Ist_Tmp:
            assign( bb, findShadowTmp(&mce, st->Ist.Tmp.tmp),
                        expr2vbits( &mce, st->Ist.Tmp.data) );
            break;

This seems to be the meaty call

We need some instructions to write to tags just like how they write
instructions to write A and V bits


/* Generate a shadow store.  addr is always the original address atom.
   You can pass in either originals or V-bits for the data atom, but
   obviously not both.  */

static
void do_shadow_STle ( MCEnv* mce,
                      IRAtom* addr, UInt bias,
                      IRAtom* data, IRAtom* vdata )

We need tags to keep track of tags - we need store and load tag
operations in mc_translate.c

We need helpers for store tag, load tag, and merge-two-tags

When we do 32-bit operations, we should just unify them into one tag

STORE is an expression whereas STORE is a statement

STORE has to be a statement because it has side effects (you can swap
a LOAD/STORE or two STOREs)

Input from the user is conceptually a place where you get new data

If you do ESP + 1, you need to get a new tag because of &-operators

We seem to need a parallel tmpMap

We need to create parallel helper functions to deal with tags:
VGA_REGPARM(1)
UInt MC_(helperc_LOADV1) ( Addr a )



static
void mc_new_mem_startup( Addr a, SizeT len, Bool rr, Bool ww, Bool xx )

static
void mc_new_mem_heap ( Addr a, SizeT len, Bool is_inited )

static
void mc_new_mem_mmap ( Addr a, SizeT len, Bool rr, Bool ww, Bool xx )


We may be able to mc_new_mem_heap to create tags and stuff
and zero stuff out when stack pointer moves