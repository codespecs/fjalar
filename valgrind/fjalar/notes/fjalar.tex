%% Fjalar design document
\documentclass[11pt]{report}
\usepackage{fullpage}
% \usepackage[pdftex]{graphicx} 

\begin{document}
\chapter{Implementation of Fjalar}
This chapter outlines the implementation of Fjalar, a dynamic analysis
framework for C/C++ programs. 

The Fjalar code base can be categorized into one of three core
functions: (1) DWARF parsing and processing, (2) Variable
traversal, and (3) Function entry/exit handling. Each core
functionality will be discussed in detail in its own section below.

Additionally, section 4 will outline the Fjalar tool API.

\section{DWARF parsing and processing}

\subsection{The DWARF debugging format}
The purpose of debugging information is to provide a mapping between
the low-level information contained in a binary and symbolic,
source-level constructs, so as to allow the debugger to provide more
useful information to the programmer.

DWARF is a standardized format for debugging information. There are currently
3 versions of the DWARF format. DWARF version 1 was developed and
released in the mid 1980s, but never achieved widespread use due to
inefficiencies. DWARF version 2 was released in 1990 and is currently
the standard debugging format used by Linux binaries. Fjalar is
only designed to work with DWARF version 2. DWARF version 3 was
released in 2006 and has yet to gain wide-use, though it is backwards
compatible with DWARF version 2.

Fjalar leverages the information available in the DWARF format to
provide an interface for tools to read and modify data in a target
program using source-level constructs.

%**NOTE**: Should I go into depth on the DWARF format

\subsection{Readelf hooks}
Due to the complex nature of both the DWARF debugging information and
the ELF binary format (the standard file format for binaries on Linux),
We make use of readelf, an existing tool for displaying information in
ELF binaries. readelf is a part of GNU binutils and is able to display
the information in a human readable form. Fjalar contains a modified
version of readelf in which all the functions for display DWARF
information are modified with calls into Fjalar code. typedata.c is
responsible for constructing a very low-level, but organized version
of the DWARF information. This low-level information closely mimics
the tree structure of the original DWARF information.

\subsection{Translating DWARF information into Fjalar data structures}
The majority of Fjalar's compile-time information is represented by
three data structures: (1) FunctionEntry, (2) VariableEntry, and (3)
TypeEntry. There declarations can be located in fjalar\_include.h

\subsubsection{FunctionEntry}
The FunctionEntry struct contains information about a particular
function. It contains the name, the name of the file which  
contains the function, the start and end address of the function's 
instructions, whether or not the function is declared as file-static,
and lists of the function's formal parameters and local variables. 

When dealing with C++ programs, a function's FunctionEntry will  
contain the mangled and demangled name of the function and, if it's a
member function, a pointer to the TypeEntry for its enclosing class.

\subsubsection{VariableEntry}
The VariableEntry struct contains information about a particular
variable in the program. It contains the name of the variable, whether
it is a global, local, formal parameter, or return variable, the
location of the variable as well as it's declared type. Additionally,
if it is a member variable of a class or struct it contains a
TypeEntry pointer for its enclosing class.


\subsubsection{TypeEntry}
The TypeEntry struct contains information about a paritcular type used
by the program. There are premade type entries for all the primitive
types defined in C(char, int, long, etc). the TypeEntry contains the
declared type of the variable, the name of the type, and the size of
the type in bytes.

If the type corresponds to a struct, class, or union (this is called
an aggregate type throughout the Fjalar source), it contains a pointer
to an AggregateType struct which contains additional information
including a list of all member variables and, in the case of C++
classes, A list of constructors, destructors, and superclasses.

\subsubsection{Translation}
generate\_fjalar\_entries.c is responsible for translating the low-level
information provided by typedata.c and translating it into the above
Fjalar data structures. It accomplishes this by taking the tree of
DWARF data and making 2 passes across it. First it makes a pass
for functions. It creates a FunctionEntry for every function contained
in the debugging information and it creates 2 hashtables for accessing
them. One is indexed by the address of the function's starting
address (referred to as the startPC), the second is indexed by the
address of the instruction corresponding to the first line of code
(referred to as the endPC). 

It then makes a second pass over the the tree and creates a 
VariableEntry and, if necessary, a TypeEntry for every Variable. It is
at this point that it associates formal parameters and local variables
with their local functions, as well as creating a list of all the
global varaibles in the program.

Finally the function table is iterated over once to make sure that
member functions and constructors/destructors are correctly referenced
by their enclosing class's TypeEntry.

This entire process takes linear time proportional to the size of the
debugging information. This process finishes fairly fast for most
programs, even particularly large C programs. Large C++ programs,
however, are known to contain large amounts of debugging information
%% FIND A CITATION FOR THIS


%and as such slowdown Fjalar's DWARF processing considerable. On one
%large C++ program Fjalar took XXXXX %% time ABB code and find out the
%% amount of dwarf information it has



\section{Function entry and exit handling}
Fjalar instruments the entry and exit of every function in the target
program. This instrumentation is to allow Fjalar to collect any
information necessary to perform a variable traversal of the function
(detailed in the following section) and to run any code requested by
the client tool.

\subsection{Determining entries and exits}
The DWARF information provides information on the first
instruction and last instructions of a function. Unfortunately, this
is insufficient for detecting entries and exits for a few reasons:

For entries, we would prefer to enter after the prologue of the
function has run, as the variable information provided by the DWARF
information tends to be valid for a function with a valid stack frame.
Fjalar

For exits, the last instruction only corresponds to one possible
exit. However, for functions with multiple exit points, the compiler
may choose to have multiple instructions which exit the function, so
going by the last instruction is not enough. Luckily, Valgrind
translates all exits out of a function into a special IR which makes
Fjalar's job easier

Valgrind allows any tool built upon it to instrument every basic block
of VEX IR before it performs the final translation back. For every
basic block Fjalar performs the following algorithm to find VEX
instructions which correspond to a function entry:

\begin{verbatim}
For every Function f:
  f.entryPC = f.firstline in DWARF[f];

iMax = 0
For every IMark instruction i:
  Look up i in FunctionEntryByStartPC 
  if functionEntry f is found:
    iMax = i
    For the remaining instructions j in i's basic block
      if j <= f.entryPC: 
        iMax = j
if iMax != 0:
  Insert enter\_function(f) before iMax

Determining exits is easier due to the VEX Instruction type
Ist\_Exit. To determine exits:

For every Exit instruction i:
  For every function f:
     if f.startPC < i and f.endPC > i:
        insert exit\_function(f) before i
\end{verbatim}

\subsubsection{Non-local exits}
Non-local exits are particularly troublesome for Fjalar due to the
fact that they do will not show up as a normal function exit in the
assembly, and accordingly do not show up in the VEX IR as EXIT
instructions. Because of this Fjalar will currently not execute exit
instrumentation for any functions that were non-locally exited.

\section{Variable Traversal}
Due to the memory-unsafe nature of C/C++ safely exploring the
variables in a target C/C++ program is a difficult
proposition. Accordingly, the handling of variable traversal is the
complex aspect of Fjalar. Variables can be broken into 2 groups:
normal variables % This is a terrible name, think of a better name % 
and pointers and arrays

For both cases the DWARF information provides us with enough
information to locate the beginning of the variable.

\subsection{Translating DWARF locations}
Locations in the DWARF information are described as a sequence of
DWARF expressions. Each DWARF expression is itself made up of a DWARF
operator and one or more DWARF atoms. All DWARF expressions work. In
addition to the DWARF atoms the DWARF operations may also perform
operations on an implicit stack. The DWARF location information can be
thought of as an instruction set for a very simple stack machine.

Fjalar currently implements a subset of this instruction set. Fjalar's
interpreter can be found in fjalar\_traversal.c and complete
information about the set of DWARF operations can be find in
include/elf/dwarf2.h and the DWARF website %link

\subsection{Normal Variables}
For these variables, Fjalar simply executes the sequence of DWARF
expressions in the DWARF information to determine the variable's
address in memory. Variables contained in registers do not need to be treated
specially as Valgrind keeps an in-memory structure of the target
program's register state. This memory address is returned to the
client tool




%% italicize?
%% http://dwarfstd.org/Debugging%20using%20DWARF.pdf
\end{document}



